{"title":"Simulation","markdown":{"yaml":{"title":"Simulation","subtitle":"Việt Nam, 2024","categories":["SupplyChainManagement","Simulation","Agent Based Modeling"],"description":"Đây là bài viết của tôi về cách sử dụng R trong việc giả lập","author":"Cao Xuân Lộc","date":"2024-11-13","title-block-banner":"img/autumn.jpg","title-block-banner-color":"white","format":{"html":{"code-fold":true,"code-tools":true}},"bibliography":"references.bib"},"headingText":"Tổng quát:","containsRefs":false,"markdown":"\n\nHôm nay chúng ta sẽ qua 1 phần khác trong **Supply chain management** đó là: giả lập (*simulation*).\n\n\n```{r}\n#| include: false\n#| message: false\n#| warning: false\npacman::p_load(\njanitor,\ntidyverse,\ndplyr,\ntidyr,\nmagrittr,\nshiny,\nleaflet,\nreactable,\nleaflet.extras,\nggplot2,\nquarto,\nreactablefmtr\n)\n```\n\n### Định nghĩa:\n\n**Simulation - giả lập** là một kĩ thuật máy tính nhằm tạo ra dữ liệu một cách ngẫu nhiên và dựa vào đó dự đoán quá trình phát triển, hoạt động của một sự vật, hiện tượng trong một đơn vị thời gian. Mục đích nhằm đánh giá mức độ hiệu quả của các giải pháp cho vấn đề, rủi ro trong tương lai.\n\nVí dụ giả lập mà bạn gặp thường ngày như dự báo thời tiết hay dự báo tình trạng lũ lụt, sạt lở trong thời gian mưa bão. Gần đây nhất là mô hình dự đoán số ca mắc Covid-19 nhằm đánh giá mức độ lây nhiễm ở các khu vực như ảnh dưới đây là kết quả dự báo ở Mỹ.\n\n```{=html}\n<div style=\"text-align: center; margin-bottom: 20px;\">\n  <img src=\"img/covid19.jpg\" style=\"max-width: 100%; height: auto; display: block; margin: 0 auto;\">\n  \n  <!-- Picture Name -->\n  <div style=\"text-align: left; margin-top: 10px;\">\n    Hình 1: Mô hình giả lập số lượng người bị nhiễm Covid-19\n  </div>\n  \n  <!-- Source Link -->\n  <div style=\"text-align: right; font-style: italic; margin-top: 5px;\">\n    Source: <a href=\"https://pubmed.ncbi.nlm.nih.gov/33097835/\" target=\"_blank\">Link to Image</a>\n  </div>\n</div>\n```\nThực chất nhiều đánh giá cho rằng các mô hình dự báo Covid-19 đều thất bại, tốn thời gian mà chẳng đưa ra *insight* gì đáng giá. Nhưng luôn nhớ rằng *\"All models are wrong but some are useful\" - George Box* nghĩa là mọi mô hình đều có sự sai lệch và nhiệm vụ của bạn là tìm ra mô hình phù hợp nhất và tạo ra giá trị trong đời thực.\n\nCác lợi ích của việc *simulation* là:\n\n-   **Kiểm tra trực giác thống kê** hoặc minh họa các đặc tính toán học mà bạn không thể dễ dàng dự đoán. Ví dụ: Kiểm tra xem liệu có hơn 5% tác động có ý nghĩa đối với một biến trong mô hình khi dữ liệu giả ngẫu nhiên được tạo ra.\n\n-   **Hiểu lý thuyết mẫu và phân phối xác suất** hoặc kiểm tra xem bạn có hiểu các quá trình cơ bản của hệ thống của mình hay không. Ví dụ: Xem liệu dữ liệu mô phỏng lấy từ các phân phối cụ thể có thể so sánh với dữ liệu thực tế hay không.\n\n-   **Thực hiện phân tích độ mạnh của mẫu**. Ví dụ: Đánh giá xem kích thước mẫu (trong mỗi lần lặp của mô phỏng) có đủ lớn để phát hiện tác động mô phỏng trong hơn 80% các trường hợp hay không.\n\n-   **Chuẩn bị kế hoạch phân tích trước**. Để tự tin về các phân tích thống kê (xác nhận) mà bạn muốn thực hiện trước khi thu thập dữ liệu (ví dụ: thông qua việc đăng ký trước hoặc báo cáo đã đăng ký), việc thực hành các phân tích trên một bộ dữ liệu mô phỏng là rất hữu ích! Nếu bạn vẫn chưa chắc chắn về bài kiểm tra thống kê phù hợp nhất để áp dụng cho dữ liệu của mình, việc cung cấp bộ dữ liệu mô phỏng cho một nhà thống kê hoặc người hướng dẫn sẽ giúp họ đưa ra các gợi ý cụ thể! Mã nguồn chứa các phân tích dữ liệu mô phỏng có thể được nộp cùng với việc đăng ký trước hoặc báo cáo đã đăng ký để các nhà phản biện hiểu rõ chính xác các phân tích bạn dự định thực hiện. Khi bạn có dữ liệu thực tế, bạn chỉ cần cắm chúng vào mã này và ngay lập tức có kết quả của các phân tích xác nhận!\n\n### Phân loại:\n\nTheo lịch sự phát triển, *simulation* có thể được chia thành các phân lớp như sau:\n\n```{=html}\n<div style=\"text-align: center; margin-bottom: 20px;\">\n  <img src=\"img/simulationmodel.png\" style=\"max-width: 100%; height: auto; display: block; margin: 0 auto;\">\n  \n  <!-- Picture Name -->\n  <div style=\"text-align: left; margin-top: 10px;\">\n    Hình 2: Phân nhánh của simulation\n  </div>\n  \n  <!-- Source Link -->\n  <div style=\"text-align: right; font-style: italic; margin-top: 5px;\">\n    Source: <a href=\"https://softwaresim.com/blog/types-of-simulation-models-choosing-the-right-approach-for-your-simulation-project/\" target=\"_blank\">Link to Image</a>\n  </div>\n</div>\n```\nTrong đó:\n\n-   2 nhánh lớn là *Deterministic* vs *Stochastic*: sự khác nhau rõ ràng nhất chính là *outcome* của 2 mô hình này. Đối với *Deterministic* thì *outcome* hoàn toàn dự đoán được, ví dụ với 1 lượng thông tin đầu vào như hình dạng tay chân, kích thước, màu sắc,... thì kết quả cuối cùng là phân biệt được đâu là hình ảnh của con chó hoặc con mèo và quan trọng là không có *randomness* từ mô hình - nghĩa là kết quả chỉ có là con chó hoặc con mèo. Còn với *Stochastic* thì thông tin đầu vào sẽ không rõ ràng như *Deterministic* - có thể là do sai lệch từ việc đo lường hoặc do chưa đủ thông tin nên *outcome* của nó cũng nằm trong 1 khoảng hoặc 1 tập hợp các giá trị khả thi.\n\n-   2 nhánh nhỏ là *Static* vs *Dynamic*: mô hình *Static* thì diễn tả một quá trình mô phỏng tại 1 điểm, 1 mốc thời gian cụ thể và mô hình *Dynamic* cũng diễn tả như vậy nhưng quá trình mô phỏng thay đổi theo thời gian. Tiêu biểu của *Static* là phương pháp *Monte Carlo* dựa trên nền tảng về *random sampling*.\n\n## Các mô hình thông dụng trong Supply Chain Simulation:\n\nỨng dụng của **Simulation** trong *Supply chain* là rất nhiều, đặc biệt ở phân mảng *planning*. Việc giả lập trước các trường hợp, tình huống có thể gặp phải là quan trọng và nó giúp người quản lí đưa ra được các phương án thay thế hoặc phương án *backup* để đảm bảo chuỗi cung ứng hoạt động bình thường.\n\nRiêng trong ngành Supply Chain thì các mô hình được sử dụng nhiều nhất bao gồm: *DES - Discrete Event Simulation* và *ABM - Agent Based Modeling*.\n\n```{=html}\n<div style=\"text-align: center; margin-bottom: 20px;\">\n  <img src=\"img/simulation.png\" style=\"max-width: 100%; height: auto; display: block; margin: 0 auto;\">\n  \n  <!-- Picture Name -->\n  <div style=\"text-align: left; margin-top: 10px;\">\n    Hình 3: Các mô hình phổ biến trong ngành Supply Chain\n  </div>\n  \n  <!-- Source Link -->\n  <div style=\"text-align: right; font-style: italic; margin-top: 5px;\">\n    Source: <a href=\"https://www.supplychaindataanalytics.com/simulation-methods-for-scm-analysts/\" target=\"_blank\">Link to Image</a>\n  </div>\n</div>\n```\n-   *DES*: hướng tới mô hình hóa quy trình hoạt động của đối tượng, tựa như flowchart của process mà bạn có thể học trong quản trị vận hành. Ví dụ quá trình vận chuyển hàng từ khi có đơn bao gồm: KH đặt hàng -\\> CS nhận đơn và thông báo -\\> WH nhận thông tin đơn hàng và chuẩn bị hàng -\\> WH giao hàng cho Shipper -\\> Shipper vận chuyển đến tận nhà hoặc tới DC -\\> KH nhận hàng từ shipper hoặc ra DC lấy.\n\nVậy dựa vào các đặc tính đó, *DES* có thể giúp bạn trả lời các câu hỏi như: Khi nào xe chở hàng? ETA và ETD cụ thể bao nhiêu ?, ...\n\n```{=html}\n<div style=\"text-align: center; margin-bottom: 20px;\">\n  <img src=\"img/DESmodel.png\" style=\"max-width: 100%; height: auto; display: block; margin: 0 auto;\">\n  \n  <!-- Picture Name -->\n  <div style=\"text-align: left; margin-top: 10px;\">\n    Hình 4:  Mô hình DES trong dự báo nhu cầu cho Volvo\n  </div>\n  \n  <!-- Source Link -->\n  <div style=\"text-align: right; font-style: italic; margin-top: 5px;\">\n    Source: <a href=\"https://www.diva-portal.org/smash/get/diva2:1465779/FULLTEXT02\" target=\"_blank\">Link to Image</a>\n  </div>\n</div>\n```\nNhư hình trên này là 1 ứng dụng *DES* vào việc dự báo nhu cầu khách hàng của Volvo trong nghiên cứu của [@jagathishvarjayakumar2020].\n\n-   *ABM*: là mô hình dựa vào *behaviors - hành vi* của từng object và đưa chúng vào *enviroment* để tự tương tác và thu lại dữ liệu. Về lí thuyết,*ABM* sẽ chi tiết và đánh giá kĩ hơn *DES* nên đó cũng là lý do *ABM* được ưu tiên sử dụng trong thời gian gần đây nhưng điều này cũng đòi hỏi độ chính xác cao về dữ liệu đầu vào để tránh sự sai lệch do độ nhạy cảm cao của mô hình này. Còn trên thực tế, mô hình nào tốt hơn còn tùy vào trường hợp mà bạn đối mặt.\n\nMột ví dụ thực tế của mô hình *ABM* là trong nghiên cứu [@hiroyasuinoue2023] về giả lập sự tác động của trận động đất [GEJE](https://en.wikipedia.org/wiki/2011_T%C5%8Dhoku_earthquake_and_tsunami) nổi tiếng từng cản quết Nhật Bản đến hoạt động sản xuất của công ty.\n\n```{=html}\n<div style=\"text-align: center; margin-bottom: 20px;\">\n  <img src=\"img/ABMmodel.png\" style=\"max-width: 100%; height: auto; display: block; margin: 0 auto;\">\n  \n  <!-- Picture Name -->\n  <div style=\"text-align: left; margin-top: 10px;\">\n    Hình 5: Mô hình ABM dự báo sự mất mát kinh tế do ảnh hưởng bởi GEJE\n  </div>\n  \n  <!-- Source Link -->\n  <div style=\"text-align: right; font-style: italic; margin-top: 5px;\">\n    Source: <a href=\"https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0288062\" target=\"_blank\">Link to Image</a>\n  </div>\n</div>\n```\nMô hình trên đã giả lập sự mất mát về kinh tế (*economic loss*) gây bởi *supply chain disruption* theo thời gian tính từ lúc cơn động đất xảy ra. Đồng thời kết quả cũng cho thấy sự khác biệt so với nghiên cứu trước đây và lý do của sự chênh lệch này là việc mất điện kéo dài ảnh hưởng nặng đến hoạt động sản xuất và gây tổn thất cho ngành sản xuất Nhật Bản.\n\nNhư vậy, các bạn có thể thấy tính ứng dụng cao của *simulation* trong đời thực. Đối với các bài toán thực tế, tùy vào mức độ phức tạp, người dùng có thể ưu tiên *ABM* hay *DES* hoặc có thể phối hợp cả hai thuật toán này.\n\nVậy để việc *simulation* diễn ra tốt, mình sẽ cập nhập thêm các kiến thức sau đây.\n\n### Lý thuyết hàng chờ:\n\nĐầu tiên là *Queueing* hay còn gọi là hàng chờ là một chuỗi các đối tượng đang chờ đợi được phục vụ và hoàn thành yêu cầu của mình từ các *server* trong hệ thống. Nói một cách đơn giản là giống như bạn đi mua trà sữa và đang đứng chờ tới lượt mình để order, sau đó đợi trà sữa được làm xong và lấy trà sữa và trở về nhà. Với góc nhìn của khách hàng thì không ai muốn chờ đợi, còn góc nhìn của chủ cửa hàng thì không muốn hàng chờ phải dài (mặc dù như vậy đồng nghĩa với cửa hàng đang đông khách nhưng hàng chờ dài sẽ làm khó chịu khách hàng và dẫn đến mất khách).\n\n```{=html}\n<div style=\"text-align: center; margin-bottom: 20px;\">\n  <img src=\"img/step.png\" style=\"max-width: 100%; height: auto; display: block; margin: 0 auto;\">\n  \n  <!-- Picture Name -->\n  <div style=\"text-align: left; margin-top: 10px;\">\n    Hình 6: Ví dụ về queueing trong quản lí nhà kho\n  </div>\n  \n  <!-- Source Link -->\n  <div style=\"text-align: right; font-style: italic; margin-top: 5px;\">\n    Source: <a href=\"https://chatgpt.com/\" target=\"_blank\">Link to Image</a>\n  </div>\n</div>\n```\nNhư vậy, mục tiêu là: đảm bảo hàng chờ ở mức **tối ưu nhất** để cân bằng giữa cấp độ phục vụ (Vd: đảm bảo khách hàng hài lòng) và chi phí. Lý do vì sao mình nói rằng là **tối ưu nhất** chứ không phải là giảm tới mức hàng chờ = 0 là vì hàng chờ luôn luôn tồn tại cho dù bạn có tốn bao nhiêu tài nguyên vào *server*. Nó giống như nghịch lý quy hoạch đô thị rằng: \"Xây thêm đường sẽ không giảm kẹt xe\" và nghịch lý vận tải: \"Đường càng rộng thì càng kẹt xe\" của [Matthew A. Turner](https://vivo.brown.edu/display/mturner1) và [Gilles Duranton](https://knowledge.wharton.upenn.edu/faculty/gilles-duranton/), nghĩa là bạn chỉ giảm khoảng cách của hàng kẹt xe chứ không hoàn toàn xóa bỏ tình trạng kẹt xe. Vì vậy, ví dụ nếu cửa hàng của bạn luôn tồn tại hàng chờ cỡ 5-6 người/hàng thì bạn chỉ cần thuê thêm 1 nhân viên đứng trực là hàng chờ giảm còn 2-3 người thay vì 5 nhân viên để hàng chờ giảm còn 0 bởi như vậy là tốn chi phí và không hiệu quả.\n\nVậy làm sao để xây dựng mô hình hàng chờ cho cửa hàng của bạn ? Đầu tiên ta cần xác định được lượng khách hàng trong một khoảng thời gian cụ thể (Vd: ngày, tuần, tháng,...) tuân theo phân bố gì, trong đó các phân bố như phân phối hàm mũ, phân phối Poisson được sử dụng phổ biến.\n\n```{r}\n#| warning: false\n#| message: false\n# Load necessary library\nset.seed(123)  \n\n# Define customer flow pattern for different times of the day\n# Morning rush: 8:30 AM - 10:30 AM\n# Midday: 10:30 AM - 2:00 PM\n# Afternoon: 2:00 PM - 4:30 PM\n# Evening rush: 4:30 PM - 7:00 PM\n# Late evening: 7:00 PM - 10:00 PM\n\n# Function to generate number of customers based on time of day\ngenerate_customers <- function(time) {\n  hour <- as.numeric(format(time, \"%H\"))\n  \n  if (hour >= 8 && hour < 10) {\n    # Morning rush (8:30 AM - 10:30 AM)\n    return(sample(20:35, 1))  # 20 to 35 customers\n  } else if (hour >= 10 && hour < 14) {\n    # Midday (10:30 AM - 2:00 PM)\n    return(sample(20:32, 1))  # 20 to 32 customers\n  } else if (hour >= 14 && hour < 16) {\n    # Afternoon slump (2:00 PM - 4:30 PM)\n    return(sample(10:18, 1))  # 10 to 18 customers\n  } else if (hour >= 16 && hour < 19) {\n    # Evening rush (4:30 PM - 7:00 PM)\n    return(sample(30:50, 1))  # 30 to 50 customers\n  } else if (hour >= 19 && hour <= 22) {\n    # Late evening (7:00 PM - 10:00 PM)\n    return(sample(12:18, 1))  # 12 to 18 customers\n  }\n}\n\ntime_intervals<-seq(from = as.POSIXct(\"2024-11-11 08:30:00\",tz = \"UTC\"),\n\n                    to = as.POSIXct(\"2024-11-11 22:00:00\",tz = \"UTC\"),\n\n                    by = \"30 min\")\n\n# Apply the function to generate customer data for each time interval\ncustomer_data <- sapply(time_intervals, generate_customers)\n\n# Create a data frame with time and customer count\ncoffee_data <- data.frame(\n  Time = as.numeric(time_intervals)*1000,\n  Customers = customer_data\n)\n\nlibrary(highcharter)\nhchart(\n  coffee_data,\n  'line', \n  hcaes(y = Customers,\n        x = Time)\n  ) |> \n  hc_xAxis(title = FALSE,type = \"datetime\") |> \n  hc_yAxis(\n    title = list(text = \"Number of Customers\")\n  ) |> \n  hc_title(text = \"No.Customer through a normal day in Coffee Shop\")\n```\n\nCách xác định là chia lượng người vào cửa hàng theo từng khoảng thời gian bằng nhau, như trên ví dụ đây là 30 phút trong khoảng thời gian hoạt động từ 8h00 AM đến 22h00 PM. Kết quả kiểm định được trình bày bên dưới với giá trị p \\< 0.05 cho thấy số lượng khách hàng tuân theo phân bố poisson (Mặc dù dữ liệu này được mình tạo ngẫu nhiên bởi chatGPT 😮😮😮).\n\n```{r}\n#| warning: false\n#| message: false\n#| include: false\n# Table of observed frequencies\nobs_freq <- table(coffee_data$Customers)\n# Expected frequencies based on Poisson distribution\nlambda <- mean(coffee_data$Customers)\nexp_freq <- dpois(as.numeric(names(obs_freq)), lambda) * length(data)\n\n# Perform Chi-squared test\nresult <- chisq.test(obs_freq, p = exp_freq, rescale.p = TRUE)\n\n# Create a data frame for gt()\nresult_df <- data.frame(\n  Metric = c(\"Chi-squared Statistic\", \n             \"Degrees of Freedom\", \"p-value\"),\n  Value = c(round(result$statistic,4), \n            result$parameter, \n            format(result$p.value, \n                   scientific = TRUE, \n                   digits = 2))\n)\n\ncounts_df <- data.frame(\nCategory = as.numeric(names(obs_freq)),\nObserved = as.vector(obs_freq),\n`P-value` = round(exp_freq,4)\n)\n```\n\n::: panel-tabset\n### Count table:\n\n```{r}\n#| warning: false\n#| message: false\nlibrary(gt)\n# Print Observed vs. Expected Counts Table\ngt(counts_df) %>%\n  tab_header(\n    title = \"Observed Counts vs P-value\"\n  ) %>%\n  tab_spanner(\n    label = \"Counts\",\n    columns = c(\"Observed\", \"P.value\")\n  ) %>%\n  tab_style(\n    style = list(\n      cell_text(weight = \"bold\")\n    ),\n    locations = cells_column_labels(columns = everything())\n  )\n```\n\n### Chi-squared test:\n\n```{r}\n# Print Chi-squared Test Results Table\ngt(result_df) %>%\n  tab_header(\n    title = \"Chi-squared Test Results\"\n  ) %>%\n  tab_spanner(\n    label = \"Test Statistics\",\n    columns = c(\"Value\")\n  ) %>%\n  tab_style(\n    style = list(\n      cell_text(weight = \"bold\")\n    ),\n    locations = cells_column_labels(columns = everything())\n  )\n```\n:::\n\nTiếp theo là xác định năng suất của *server* trong 1 đơn vị thời gian. Giả sử nhân viên của bạn có năng suất là như nhau và phục vụ trung bình được 1 đơn hàng/10 phút hay 6 đơn hàng/giờ thì ta có $\\mu$ = 6\n\nSau đó chúng ta sẽ bắt đầu quá trình giả lập và bạn có thể sử dụng 2 cách: (i) Phương pháp giải tích (giải phương trình toán học bằng tay) hoặc (ii) Phương pháp máy tính (giả lập bằng máy). Với **R** thì bạn hoàn toàn làm điều này dễ hơn.\n\nNhư dưới đây là ví dụ về việc giả lập thời gian phục vụ của quán cà phê với 2 hoặc 3 hoặc 4 nhân viên trực quán.\n\n```{r}\n#| include: false\n#| warning: false\n#| message: false\nlibrary(simmer)\nsimulate_shop <- function(employee) {\n  labor_capacity <- 12 / 60  # Service rate per minute\n  \n  # Initialize the simulation\n  sim <- simmer(\"CoffeeShop\")\n  \n  # Define the customer process\n  customer_process <- trajectory(\"customer\") %>%\n    seize(\"barista\", 1) %>%\n    timeout(function() rexp(1, rate = labor_capacity)) %>%\n    release(\"barista\", 1)\n  \n  # Add barista resource to the simulation\n  sim <- sim %>%\n    add_resource(\"barista\", capacity = employee)\n  \n  # Schedule customer arrivals\n  start_time <- as.numeric(time_intervals[1])  # Convert start time to POSIX numeric\n\n  customer_id <- 1  # Initialize a counter for unique customer naming\n\n  for (j in 1:length(customer_data)) {\n    num_customers <- customer_data[j]\n    interval_start <- as.numeric(time_intervals[j])  # Start of each 30-min interval in POSIX numeric\n\n    for (k in 1:num_customers) {\n      arrival_offset <- runif(1, 0, 1800)  # Random arrival within 30 mins\n      arrival_time <- interval_start + arrival_offset  # Actual arrival time in POSIX numeric\n      \n      # Convert to relative time (in minutes) from start_time\n      relative_arrival <- (arrival_time - start_time) / 60\n      \n      # Generate a unique name for each customer\n      customer_name <- paste0(\"customer_\", customer_id)\n      customer_id <- customer_id + 1  # Increment the unique ID\n      \n      # Add customer generator with a unique name\n      sim <- sim %>%\n        add_generator(customer_name, \n                      customer_process, \n                      at(relative_arrival))\n    }\n  }\n  \n  # Run the simulation from 8:30 AM to 10:00 PM means 28 periods of 30 minutes\n  sim %>% \n    run(until = (22 - 8) * 2 * 60)\n  \n  return(sim)\n}\n\nsim2<-simulate_shop(2)\nsim3<-simulate_shop(3)\nsim4<-simulate_shop(4)\n```\n\n::: panel-tabset\n### 2 employee:\n\n```{r}\n#| echo: false\narrival_data <- sim2  %>%\nget_mon_arrivals() \n\narrival_data<-arrival_data |> \n  dplyr::select(c(start_time,\n           end_time,\n           activity_time)) |> \n  pivot_longer(cols = everything(),\n               values_to = \"time\",\n               names_to = \"type\")\nhighcharter::hchart(\n  arrival_data,\n  'line', \n  hcaes(y = time, \n        group = type)\n) |> \n  hc_tooltip(\n    pointFormat = '{point.x: %Y-%m-%d} ',\n    headerFormat = '',\n    useHTML = TRUE,\n    formatter = JS(\n      \"function() {\n         var baseTime = Date.parse('2024-11-11 08:30:00 UTC'); // Base time\n         var timeOffset = this.y * 60000; // Convert minutes to milliseconds\n         var calculatedTime = new Date(baseTime + timeOffset);\n         return '<b>' + this.series.name + '</b><br>' +\n                'Time: ' + Highcharts.dateFormat('%Y-%m-%d %H:%M:%S UTC', calculatedTime);\n       }\"\n    )\n  )\n```\n\n### 3 employee:\n\n```{r}\n#| echo: false\nlibrary(highcharter)\narrival_data <- sim3 %>%\n  get_mon_arrivals() \n\narrival_data<-arrival_data |> \n  dplyr::select(c(start_time,\n           end_time,\n           activity_time)) |> \n  pivot_longer(cols = everything(),\n               values_to = \"time\",\n               names_to = \"type\")\nhchart(\n  arrival_data,\n  'line', \n  hcaes(y = time, group = type)\n) |> \n  hc_tooltip(\n    pointFormat = '{point.x: %Y-%m-%d} ',\n    headerFormat = '',\n    useHTML = TRUE,\n    formatter = JS(\n      \"function() {\n         var baseTime = Date.parse('2024-11-11 08:30:00 UTC'); // Base time\n         var timeOffset = this.y * 60000; // Convert minutes to milliseconds\n         var calculatedTime = new Date(baseTime + timeOffset);\n         return '<b>' + this.series.name + '</b><br>' +\n                'Time: ' + Highcharts.dateFormat('%Y-%m-%d %H:%M:%S UTC', calculatedTime);\n       }\"\n    )\n  )\n```\n\n### 4 employee:\n\n```{r}\n#| echo: false\narrival_data <- sim4  %>%\n  get_mon_arrivals()\n  \nlibrary(highcharter)\narrival_data |> \n  dplyr::select(c(start_time,\n           end_time,\n           activity_time)) |> \n  pivot_longer(cols = everything(),\n               values_to = \"time\",\n               names_to = \"type\") |> \n  hchart(\n  'line', \n  hcaes(y = time,\n        group = type)\n  ) |> \n   hc_tooltip(\n    pointFormat = '{point.x: %Y-%m-%d} ',\n    headerFormat = '',\n    useHTML = TRUE,\n     formatter = JS(\n      \"function() {\n         var baseTime = Date.parse('2024-11-11 08:30:00 UTC'); // Base time\n         var timeOffset = this.y * 60000; // Convert minutes to milliseconds\n         var calculatedTime = new Date(baseTime + timeOffset);\n         return '<b>' + this.series.name + '</b><br>' +\n                'Time: ' + Highcharts.dateFormat('%Y-%m-%d %H:%M:%S UTC', calculatedTime);\n       }\"\n    )\n  )\n```\n:::\n\nKết quả cho thấy cửa hàng nên thuê 4 người để đảm bảo *server level* ở dạng cao. Nếu cửa hàng chỉ thuê 2 người thì thời gian đợi phục vụ trung bình của khách hàng là khoảng **7.5 tiếng** (Một con số hơi khủng, tưởng đang sử dụng dịch vụ của Vietjet cơ! 😄😄😄) trong khi nếu thuê thêm 2 người thì giảm xuống còn **41.5 phút** \\~ giảm thời gian chờ đợi xuống **11 lần**.\n\n### Lý thuyết thống kê:\n\nTiếp theo, bạn cần lý thuyết thống kê về chuyên ngành của vấn đề mà bạn đang mong muốn mô hình hóa. Việc xác định các đối tượng trong *server* và đối tượng mục tiêu cần giả lập cũng như các đặc tính cần có trong mô hình là quan trọng bởi chúng là sườn sống của mô hình giả lập. Ví dụ như quy trình hoạt động của quán cafe là như thế nào, sẽ hoạt động ra sao trong nhiều trường hợp,... càng rõ thì việc giả lập càng sát với thực tế.\n\nĐặc biệt với các ngành về y sinh học, giả lập quần thể là công việc hằng ngày của các nghiên cứu sinh nên việc hiểu rõ bản chất của quần thể đó quan trọng hơn cách thức hay phương pháp giả lập.\n\nVề code, bạn cần lưu ý rằng *sample size - số lượng mẫu* ảnh hưởng lớn đến độ chính xác (*precision*) của đo lường ảnh hưởng của biến đó. Điều này cũng tương tự với độ lặp lại (*replication*) nghĩa là bạn lặp lại nhiều lần việc tính toán thì kết quả sẽ tốt hoặc chính xác hơn.\n\nTiếp theo, ta sẽ thực hành trong R.\n\n```{=html}\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Go to Next Page</title>\n    <style>\n        /* Global Styles */\n        body {\n            font-family: 'Tahoma', sans-serif;\n            display: flex;\n            flex-direction: column;  /* Stack content and footnote vertically */\n            justify-content: center;  /* Center content vertically */\n            align-items: center;      /* Center content horizontally */\n            margin: 0;\n            background-color: $secondary-color;\n            box-sizing: border-box;\n            min-height: 80vh; /* Adjusted to 80vh to ensure it's not too high */\n        }\n\n        /* Container Styling (Main Content) */\n        .container {\n            text-align: center;\n            padding: 20px 40px; /* Adjust padding for more compactness */\n            background-color: white;\n            border-radius: 12px;\n            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);\n            width: auto;  /* Auto width to fit content */\n            max-width: 380px;  /* Adjusted max-width for a smaller container */\n            box-sizing: border-box;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            flex-direction: column;\n            margin-top: 20px;  /* Space from the top of the page */\n        }\n\n        /* Link Styling */\n        .link {\n            font-size: 20px;  /* Adjusted font size for readability */\n            color: #007bff;\n            text-decoration: none;\n            font-weight: 700;\n            display: inline-flex;\n            align-items: center;\n            cursor: pointer;\n            padding: 12px 30px;\n            border-radius: 6px;\n            transition: all 0.3s ease;\n        }\n\n        .link:hover {\n            color: #0056b3;\n            text-decoration: none;\n            background-color: #e6f0ff;\n        }\n\n        /* Arrow Styling */\n        .arrow {\n            margin-left: 12px;\n            font-size: 24px;\n            transition: transform 0.3s ease, font-size 0.3s ease;\n        }\n\n        .link:hover .arrow {\n            transform: translateX(8px);\n            font-size: 26px;\n        }\n\n        /* Focus State for Accessibility */\n        .link:focus {\n            outline: 2px solid #0056b3;\n        }\n\n        /* Footer Styling (Footnote) */\n        .footer {\n            font-size: 14px;\n            color: #777;\n            margin-top: 20px;  /* Space between content and footnote */\n            text-align: center;\n            width: 100%;\n        }\n\n        /* Mobile-Friendly Adjustments */\n        @media (max-width: 600px) {\n            .link {\n                font-size: 18px;\n                padding: 8px 15px;  /* Smaller padding for mobile devices */\n            }\n\n            .arrow {\n                font-size: 18px;\n                margin-left: 8px;\n            }\n\n            .container {\n                padding: 15px 30px;  /* Smaller padding on mobile */\n                max-width: 90%;  /* Ensure container fits better on small screens */\n            }\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <a href=\"https://loccx78vn.github.io/Simulation_in_R/practice.html\" class=\"link\" tabindex=\"0\">\n            Go to Next Page\n            <span class=\"arrow\">➔</span>\n        </a>\n    </div>\n</body>\n</html>\n```\n","srcMarkdownNoYaml":"\n\nHôm nay chúng ta sẽ qua 1 phần khác trong **Supply chain management** đó là: giả lập (*simulation*).\n\n## Tổng quát:\n\n```{r}\n#| include: false\n#| message: false\n#| warning: false\npacman::p_load(\njanitor,\ntidyverse,\ndplyr,\ntidyr,\nmagrittr,\nshiny,\nleaflet,\nreactable,\nleaflet.extras,\nggplot2,\nquarto,\nreactablefmtr\n)\n```\n\n### Định nghĩa:\n\n**Simulation - giả lập** là một kĩ thuật máy tính nhằm tạo ra dữ liệu một cách ngẫu nhiên và dựa vào đó dự đoán quá trình phát triển, hoạt động của một sự vật, hiện tượng trong một đơn vị thời gian. Mục đích nhằm đánh giá mức độ hiệu quả của các giải pháp cho vấn đề, rủi ro trong tương lai.\n\nVí dụ giả lập mà bạn gặp thường ngày như dự báo thời tiết hay dự báo tình trạng lũ lụt, sạt lở trong thời gian mưa bão. Gần đây nhất là mô hình dự đoán số ca mắc Covid-19 nhằm đánh giá mức độ lây nhiễm ở các khu vực như ảnh dưới đây là kết quả dự báo ở Mỹ.\n\n```{=html}\n<div style=\"text-align: center; margin-bottom: 20px;\">\n  <img src=\"img/covid19.jpg\" style=\"max-width: 100%; height: auto; display: block; margin: 0 auto;\">\n  \n  <!-- Picture Name -->\n  <div style=\"text-align: left; margin-top: 10px;\">\n    Hình 1: Mô hình giả lập số lượng người bị nhiễm Covid-19\n  </div>\n  \n  <!-- Source Link -->\n  <div style=\"text-align: right; font-style: italic; margin-top: 5px;\">\n    Source: <a href=\"https://pubmed.ncbi.nlm.nih.gov/33097835/\" target=\"_blank\">Link to Image</a>\n  </div>\n</div>\n```\nThực chất nhiều đánh giá cho rằng các mô hình dự báo Covid-19 đều thất bại, tốn thời gian mà chẳng đưa ra *insight* gì đáng giá. Nhưng luôn nhớ rằng *\"All models are wrong but some are useful\" - George Box* nghĩa là mọi mô hình đều có sự sai lệch và nhiệm vụ của bạn là tìm ra mô hình phù hợp nhất và tạo ra giá trị trong đời thực.\n\nCác lợi ích của việc *simulation* là:\n\n-   **Kiểm tra trực giác thống kê** hoặc minh họa các đặc tính toán học mà bạn không thể dễ dàng dự đoán. Ví dụ: Kiểm tra xem liệu có hơn 5% tác động có ý nghĩa đối với một biến trong mô hình khi dữ liệu giả ngẫu nhiên được tạo ra.\n\n-   **Hiểu lý thuyết mẫu và phân phối xác suất** hoặc kiểm tra xem bạn có hiểu các quá trình cơ bản của hệ thống của mình hay không. Ví dụ: Xem liệu dữ liệu mô phỏng lấy từ các phân phối cụ thể có thể so sánh với dữ liệu thực tế hay không.\n\n-   **Thực hiện phân tích độ mạnh của mẫu**. Ví dụ: Đánh giá xem kích thước mẫu (trong mỗi lần lặp của mô phỏng) có đủ lớn để phát hiện tác động mô phỏng trong hơn 80% các trường hợp hay không.\n\n-   **Chuẩn bị kế hoạch phân tích trước**. Để tự tin về các phân tích thống kê (xác nhận) mà bạn muốn thực hiện trước khi thu thập dữ liệu (ví dụ: thông qua việc đăng ký trước hoặc báo cáo đã đăng ký), việc thực hành các phân tích trên một bộ dữ liệu mô phỏng là rất hữu ích! Nếu bạn vẫn chưa chắc chắn về bài kiểm tra thống kê phù hợp nhất để áp dụng cho dữ liệu của mình, việc cung cấp bộ dữ liệu mô phỏng cho một nhà thống kê hoặc người hướng dẫn sẽ giúp họ đưa ra các gợi ý cụ thể! Mã nguồn chứa các phân tích dữ liệu mô phỏng có thể được nộp cùng với việc đăng ký trước hoặc báo cáo đã đăng ký để các nhà phản biện hiểu rõ chính xác các phân tích bạn dự định thực hiện. Khi bạn có dữ liệu thực tế, bạn chỉ cần cắm chúng vào mã này và ngay lập tức có kết quả của các phân tích xác nhận!\n\n### Phân loại:\n\nTheo lịch sự phát triển, *simulation* có thể được chia thành các phân lớp như sau:\n\n```{=html}\n<div style=\"text-align: center; margin-bottom: 20px;\">\n  <img src=\"img/simulationmodel.png\" style=\"max-width: 100%; height: auto; display: block; margin: 0 auto;\">\n  \n  <!-- Picture Name -->\n  <div style=\"text-align: left; margin-top: 10px;\">\n    Hình 2: Phân nhánh của simulation\n  </div>\n  \n  <!-- Source Link -->\n  <div style=\"text-align: right; font-style: italic; margin-top: 5px;\">\n    Source: <a href=\"https://softwaresim.com/blog/types-of-simulation-models-choosing-the-right-approach-for-your-simulation-project/\" target=\"_blank\">Link to Image</a>\n  </div>\n</div>\n```\nTrong đó:\n\n-   2 nhánh lớn là *Deterministic* vs *Stochastic*: sự khác nhau rõ ràng nhất chính là *outcome* của 2 mô hình này. Đối với *Deterministic* thì *outcome* hoàn toàn dự đoán được, ví dụ với 1 lượng thông tin đầu vào như hình dạng tay chân, kích thước, màu sắc,... thì kết quả cuối cùng là phân biệt được đâu là hình ảnh của con chó hoặc con mèo và quan trọng là không có *randomness* từ mô hình - nghĩa là kết quả chỉ có là con chó hoặc con mèo. Còn với *Stochastic* thì thông tin đầu vào sẽ không rõ ràng như *Deterministic* - có thể là do sai lệch từ việc đo lường hoặc do chưa đủ thông tin nên *outcome* của nó cũng nằm trong 1 khoảng hoặc 1 tập hợp các giá trị khả thi.\n\n-   2 nhánh nhỏ là *Static* vs *Dynamic*: mô hình *Static* thì diễn tả một quá trình mô phỏng tại 1 điểm, 1 mốc thời gian cụ thể và mô hình *Dynamic* cũng diễn tả như vậy nhưng quá trình mô phỏng thay đổi theo thời gian. Tiêu biểu của *Static* là phương pháp *Monte Carlo* dựa trên nền tảng về *random sampling*.\n\n## Các mô hình thông dụng trong Supply Chain Simulation:\n\nỨng dụng của **Simulation** trong *Supply chain* là rất nhiều, đặc biệt ở phân mảng *planning*. Việc giả lập trước các trường hợp, tình huống có thể gặp phải là quan trọng và nó giúp người quản lí đưa ra được các phương án thay thế hoặc phương án *backup* để đảm bảo chuỗi cung ứng hoạt động bình thường.\n\nRiêng trong ngành Supply Chain thì các mô hình được sử dụng nhiều nhất bao gồm: *DES - Discrete Event Simulation* và *ABM - Agent Based Modeling*.\n\n```{=html}\n<div style=\"text-align: center; margin-bottom: 20px;\">\n  <img src=\"img/simulation.png\" style=\"max-width: 100%; height: auto; display: block; margin: 0 auto;\">\n  \n  <!-- Picture Name -->\n  <div style=\"text-align: left; margin-top: 10px;\">\n    Hình 3: Các mô hình phổ biến trong ngành Supply Chain\n  </div>\n  \n  <!-- Source Link -->\n  <div style=\"text-align: right; font-style: italic; margin-top: 5px;\">\n    Source: <a href=\"https://www.supplychaindataanalytics.com/simulation-methods-for-scm-analysts/\" target=\"_blank\">Link to Image</a>\n  </div>\n</div>\n```\n-   *DES*: hướng tới mô hình hóa quy trình hoạt động của đối tượng, tựa như flowchart của process mà bạn có thể học trong quản trị vận hành. Ví dụ quá trình vận chuyển hàng từ khi có đơn bao gồm: KH đặt hàng -\\> CS nhận đơn và thông báo -\\> WH nhận thông tin đơn hàng và chuẩn bị hàng -\\> WH giao hàng cho Shipper -\\> Shipper vận chuyển đến tận nhà hoặc tới DC -\\> KH nhận hàng từ shipper hoặc ra DC lấy.\n\nVậy dựa vào các đặc tính đó, *DES* có thể giúp bạn trả lời các câu hỏi như: Khi nào xe chở hàng? ETA và ETD cụ thể bao nhiêu ?, ...\n\n```{=html}\n<div style=\"text-align: center; margin-bottom: 20px;\">\n  <img src=\"img/DESmodel.png\" style=\"max-width: 100%; height: auto; display: block; margin: 0 auto;\">\n  \n  <!-- Picture Name -->\n  <div style=\"text-align: left; margin-top: 10px;\">\n    Hình 4:  Mô hình DES trong dự báo nhu cầu cho Volvo\n  </div>\n  \n  <!-- Source Link -->\n  <div style=\"text-align: right; font-style: italic; margin-top: 5px;\">\n    Source: <a href=\"https://www.diva-portal.org/smash/get/diva2:1465779/FULLTEXT02\" target=\"_blank\">Link to Image</a>\n  </div>\n</div>\n```\nNhư hình trên này là 1 ứng dụng *DES* vào việc dự báo nhu cầu khách hàng của Volvo trong nghiên cứu của [@jagathishvarjayakumar2020].\n\n-   *ABM*: là mô hình dựa vào *behaviors - hành vi* của từng object và đưa chúng vào *enviroment* để tự tương tác và thu lại dữ liệu. Về lí thuyết,*ABM* sẽ chi tiết và đánh giá kĩ hơn *DES* nên đó cũng là lý do *ABM* được ưu tiên sử dụng trong thời gian gần đây nhưng điều này cũng đòi hỏi độ chính xác cao về dữ liệu đầu vào để tránh sự sai lệch do độ nhạy cảm cao của mô hình này. Còn trên thực tế, mô hình nào tốt hơn còn tùy vào trường hợp mà bạn đối mặt.\n\nMột ví dụ thực tế của mô hình *ABM* là trong nghiên cứu [@hiroyasuinoue2023] về giả lập sự tác động của trận động đất [GEJE](https://en.wikipedia.org/wiki/2011_T%C5%8Dhoku_earthquake_and_tsunami) nổi tiếng từng cản quết Nhật Bản đến hoạt động sản xuất của công ty.\n\n```{=html}\n<div style=\"text-align: center; margin-bottom: 20px;\">\n  <img src=\"img/ABMmodel.png\" style=\"max-width: 100%; height: auto; display: block; margin: 0 auto;\">\n  \n  <!-- Picture Name -->\n  <div style=\"text-align: left; margin-top: 10px;\">\n    Hình 5: Mô hình ABM dự báo sự mất mát kinh tế do ảnh hưởng bởi GEJE\n  </div>\n  \n  <!-- Source Link -->\n  <div style=\"text-align: right; font-style: italic; margin-top: 5px;\">\n    Source: <a href=\"https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0288062\" target=\"_blank\">Link to Image</a>\n  </div>\n</div>\n```\nMô hình trên đã giả lập sự mất mát về kinh tế (*economic loss*) gây bởi *supply chain disruption* theo thời gian tính từ lúc cơn động đất xảy ra. Đồng thời kết quả cũng cho thấy sự khác biệt so với nghiên cứu trước đây và lý do của sự chênh lệch này là việc mất điện kéo dài ảnh hưởng nặng đến hoạt động sản xuất và gây tổn thất cho ngành sản xuất Nhật Bản.\n\nNhư vậy, các bạn có thể thấy tính ứng dụng cao của *simulation* trong đời thực. Đối với các bài toán thực tế, tùy vào mức độ phức tạp, người dùng có thể ưu tiên *ABM* hay *DES* hoặc có thể phối hợp cả hai thuật toán này.\n\nVậy để việc *simulation* diễn ra tốt, mình sẽ cập nhập thêm các kiến thức sau đây.\n\n### Lý thuyết hàng chờ:\n\nĐầu tiên là *Queueing* hay còn gọi là hàng chờ là một chuỗi các đối tượng đang chờ đợi được phục vụ và hoàn thành yêu cầu của mình từ các *server* trong hệ thống. Nói một cách đơn giản là giống như bạn đi mua trà sữa và đang đứng chờ tới lượt mình để order, sau đó đợi trà sữa được làm xong và lấy trà sữa và trở về nhà. Với góc nhìn của khách hàng thì không ai muốn chờ đợi, còn góc nhìn của chủ cửa hàng thì không muốn hàng chờ phải dài (mặc dù như vậy đồng nghĩa với cửa hàng đang đông khách nhưng hàng chờ dài sẽ làm khó chịu khách hàng và dẫn đến mất khách).\n\n```{=html}\n<div style=\"text-align: center; margin-bottom: 20px;\">\n  <img src=\"img/step.png\" style=\"max-width: 100%; height: auto; display: block; margin: 0 auto;\">\n  \n  <!-- Picture Name -->\n  <div style=\"text-align: left; margin-top: 10px;\">\n    Hình 6: Ví dụ về queueing trong quản lí nhà kho\n  </div>\n  \n  <!-- Source Link -->\n  <div style=\"text-align: right; font-style: italic; margin-top: 5px;\">\n    Source: <a href=\"https://chatgpt.com/\" target=\"_blank\">Link to Image</a>\n  </div>\n</div>\n```\nNhư vậy, mục tiêu là: đảm bảo hàng chờ ở mức **tối ưu nhất** để cân bằng giữa cấp độ phục vụ (Vd: đảm bảo khách hàng hài lòng) và chi phí. Lý do vì sao mình nói rằng là **tối ưu nhất** chứ không phải là giảm tới mức hàng chờ = 0 là vì hàng chờ luôn luôn tồn tại cho dù bạn có tốn bao nhiêu tài nguyên vào *server*. Nó giống như nghịch lý quy hoạch đô thị rằng: \"Xây thêm đường sẽ không giảm kẹt xe\" và nghịch lý vận tải: \"Đường càng rộng thì càng kẹt xe\" của [Matthew A. Turner](https://vivo.brown.edu/display/mturner1) và [Gilles Duranton](https://knowledge.wharton.upenn.edu/faculty/gilles-duranton/), nghĩa là bạn chỉ giảm khoảng cách của hàng kẹt xe chứ không hoàn toàn xóa bỏ tình trạng kẹt xe. Vì vậy, ví dụ nếu cửa hàng của bạn luôn tồn tại hàng chờ cỡ 5-6 người/hàng thì bạn chỉ cần thuê thêm 1 nhân viên đứng trực là hàng chờ giảm còn 2-3 người thay vì 5 nhân viên để hàng chờ giảm còn 0 bởi như vậy là tốn chi phí và không hiệu quả.\n\nVậy làm sao để xây dựng mô hình hàng chờ cho cửa hàng của bạn ? Đầu tiên ta cần xác định được lượng khách hàng trong một khoảng thời gian cụ thể (Vd: ngày, tuần, tháng,...) tuân theo phân bố gì, trong đó các phân bố như phân phối hàm mũ, phân phối Poisson được sử dụng phổ biến.\n\n```{r}\n#| warning: false\n#| message: false\n# Load necessary library\nset.seed(123)  \n\n# Define customer flow pattern for different times of the day\n# Morning rush: 8:30 AM - 10:30 AM\n# Midday: 10:30 AM - 2:00 PM\n# Afternoon: 2:00 PM - 4:30 PM\n# Evening rush: 4:30 PM - 7:00 PM\n# Late evening: 7:00 PM - 10:00 PM\n\n# Function to generate number of customers based on time of day\ngenerate_customers <- function(time) {\n  hour <- as.numeric(format(time, \"%H\"))\n  \n  if (hour >= 8 && hour < 10) {\n    # Morning rush (8:30 AM - 10:30 AM)\n    return(sample(20:35, 1))  # 20 to 35 customers\n  } else if (hour >= 10 && hour < 14) {\n    # Midday (10:30 AM - 2:00 PM)\n    return(sample(20:32, 1))  # 20 to 32 customers\n  } else if (hour >= 14 && hour < 16) {\n    # Afternoon slump (2:00 PM - 4:30 PM)\n    return(sample(10:18, 1))  # 10 to 18 customers\n  } else if (hour >= 16 && hour < 19) {\n    # Evening rush (4:30 PM - 7:00 PM)\n    return(sample(30:50, 1))  # 30 to 50 customers\n  } else if (hour >= 19 && hour <= 22) {\n    # Late evening (7:00 PM - 10:00 PM)\n    return(sample(12:18, 1))  # 12 to 18 customers\n  }\n}\n\ntime_intervals<-seq(from = as.POSIXct(\"2024-11-11 08:30:00\",tz = \"UTC\"),\n\n                    to = as.POSIXct(\"2024-11-11 22:00:00\",tz = \"UTC\"),\n\n                    by = \"30 min\")\n\n# Apply the function to generate customer data for each time interval\ncustomer_data <- sapply(time_intervals, generate_customers)\n\n# Create a data frame with time and customer count\ncoffee_data <- data.frame(\n  Time = as.numeric(time_intervals)*1000,\n  Customers = customer_data\n)\n\nlibrary(highcharter)\nhchart(\n  coffee_data,\n  'line', \n  hcaes(y = Customers,\n        x = Time)\n  ) |> \n  hc_xAxis(title = FALSE,type = \"datetime\") |> \n  hc_yAxis(\n    title = list(text = \"Number of Customers\")\n  ) |> \n  hc_title(text = \"No.Customer through a normal day in Coffee Shop\")\n```\n\nCách xác định là chia lượng người vào cửa hàng theo từng khoảng thời gian bằng nhau, như trên ví dụ đây là 30 phút trong khoảng thời gian hoạt động từ 8h00 AM đến 22h00 PM. Kết quả kiểm định được trình bày bên dưới với giá trị p \\< 0.05 cho thấy số lượng khách hàng tuân theo phân bố poisson (Mặc dù dữ liệu này được mình tạo ngẫu nhiên bởi chatGPT 😮😮😮).\n\n```{r}\n#| warning: false\n#| message: false\n#| include: false\n# Table of observed frequencies\nobs_freq <- table(coffee_data$Customers)\n# Expected frequencies based on Poisson distribution\nlambda <- mean(coffee_data$Customers)\nexp_freq <- dpois(as.numeric(names(obs_freq)), lambda) * length(data)\n\n# Perform Chi-squared test\nresult <- chisq.test(obs_freq, p = exp_freq, rescale.p = TRUE)\n\n# Create a data frame for gt()\nresult_df <- data.frame(\n  Metric = c(\"Chi-squared Statistic\", \n             \"Degrees of Freedom\", \"p-value\"),\n  Value = c(round(result$statistic,4), \n            result$parameter, \n            format(result$p.value, \n                   scientific = TRUE, \n                   digits = 2))\n)\n\ncounts_df <- data.frame(\nCategory = as.numeric(names(obs_freq)),\nObserved = as.vector(obs_freq),\n`P-value` = round(exp_freq,4)\n)\n```\n\n::: panel-tabset\n### Count table:\n\n```{r}\n#| warning: false\n#| message: false\nlibrary(gt)\n# Print Observed vs. Expected Counts Table\ngt(counts_df) %>%\n  tab_header(\n    title = \"Observed Counts vs P-value\"\n  ) %>%\n  tab_spanner(\n    label = \"Counts\",\n    columns = c(\"Observed\", \"P.value\")\n  ) %>%\n  tab_style(\n    style = list(\n      cell_text(weight = \"bold\")\n    ),\n    locations = cells_column_labels(columns = everything())\n  )\n```\n\n### Chi-squared test:\n\n```{r}\n# Print Chi-squared Test Results Table\ngt(result_df) %>%\n  tab_header(\n    title = \"Chi-squared Test Results\"\n  ) %>%\n  tab_spanner(\n    label = \"Test Statistics\",\n    columns = c(\"Value\")\n  ) %>%\n  tab_style(\n    style = list(\n      cell_text(weight = \"bold\")\n    ),\n    locations = cells_column_labels(columns = everything())\n  )\n```\n:::\n\nTiếp theo là xác định năng suất của *server* trong 1 đơn vị thời gian. Giả sử nhân viên của bạn có năng suất là như nhau và phục vụ trung bình được 1 đơn hàng/10 phút hay 6 đơn hàng/giờ thì ta có $\\mu$ = 6\n\nSau đó chúng ta sẽ bắt đầu quá trình giả lập và bạn có thể sử dụng 2 cách: (i) Phương pháp giải tích (giải phương trình toán học bằng tay) hoặc (ii) Phương pháp máy tính (giả lập bằng máy). Với **R** thì bạn hoàn toàn làm điều này dễ hơn.\n\nNhư dưới đây là ví dụ về việc giả lập thời gian phục vụ của quán cà phê với 2 hoặc 3 hoặc 4 nhân viên trực quán.\n\n```{r}\n#| include: false\n#| warning: false\n#| message: false\nlibrary(simmer)\nsimulate_shop <- function(employee) {\n  labor_capacity <- 12 / 60  # Service rate per minute\n  \n  # Initialize the simulation\n  sim <- simmer(\"CoffeeShop\")\n  \n  # Define the customer process\n  customer_process <- trajectory(\"customer\") %>%\n    seize(\"barista\", 1) %>%\n    timeout(function() rexp(1, rate = labor_capacity)) %>%\n    release(\"barista\", 1)\n  \n  # Add barista resource to the simulation\n  sim <- sim %>%\n    add_resource(\"barista\", capacity = employee)\n  \n  # Schedule customer arrivals\n  start_time <- as.numeric(time_intervals[1])  # Convert start time to POSIX numeric\n\n  customer_id <- 1  # Initialize a counter for unique customer naming\n\n  for (j in 1:length(customer_data)) {\n    num_customers <- customer_data[j]\n    interval_start <- as.numeric(time_intervals[j])  # Start of each 30-min interval in POSIX numeric\n\n    for (k in 1:num_customers) {\n      arrival_offset <- runif(1, 0, 1800)  # Random arrival within 30 mins\n      arrival_time <- interval_start + arrival_offset  # Actual arrival time in POSIX numeric\n      \n      # Convert to relative time (in minutes) from start_time\n      relative_arrival <- (arrival_time - start_time) / 60\n      \n      # Generate a unique name for each customer\n      customer_name <- paste0(\"customer_\", customer_id)\n      customer_id <- customer_id + 1  # Increment the unique ID\n      \n      # Add customer generator with a unique name\n      sim <- sim %>%\n        add_generator(customer_name, \n                      customer_process, \n                      at(relative_arrival))\n    }\n  }\n  \n  # Run the simulation from 8:30 AM to 10:00 PM means 28 periods of 30 minutes\n  sim %>% \n    run(until = (22 - 8) * 2 * 60)\n  \n  return(sim)\n}\n\nsim2<-simulate_shop(2)\nsim3<-simulate_shop(3)\nsim4<-simulate_shop(4)\n```\n\n::: panel-tabset\n### 2 employee:\n\n```{r}\n#| echo: false\narrival_data <- sim2  %>%\nget_mon_arrivals() \n\narrival_data<-arrival_data |> \n  dplyr::select(c(start_time,\n           end_time,\n           activity_time)) |> \n  pivot_longer(cols = everything(),\n               values_to = \"time\",\n               names_to = \"type\")\nhighcharter::hchart(\n  arrival_data,\n  'line', \n  hcaes(y = time, \n        group = type)\n) |> \n  hc_tooltip(\n    pointFormat = '{point.x: %Y-%m-%d} ',\n    headerFormat = '',\n    useHTML = TRUE,\n    formatter = JS(\n      \"function() {\n         var baseTime = Date.parse('2024-11-11 08:30:00 UTC'); // Base time\n         var timeOffset = this.y * 60000; // Convert minutes to milliseconds\n         var calculatedTime = new Date(baseTime + timeOffset);\n         return '<b>' + this.series.name + '</b><br>' +\n                'Time: ' + Highcharts.dateFormat('%Y-%m-%d %H:%M:%S UTC', calculatedTime);\n       }\"\n    )\n  )\n```\n\n### 3 employee:\n\n```{r}\n#| echo: false\nlibrary(highcharter)\narrival_data <- sim3 %>%\n  get_mon_arrivals() \n\narrival_data<-arrival_data |> \n  dplyr::select(c(start_time,\n           end_time,\n           activity_time)) |> \n  pivot_longer(cols = everything(),\n               values_to = \"time\",\n               names_to = \"type\")\nhchart(\n  arrival_data,\n  'line', \n  hcaes(y = time, group = type)\n) |> \n  hc_tooltip(\n    pointFormat = '{point.x: %Y-%m-%d} ',\n    headerFormat = '',\n    useHTML = TRUE,\n    formatter = JS(\n      \"function() {\n         var baseTime = Date.parse('2024-11-11 08:30:00 UTC'); // Base time\n         var timeOffset = this.y * 60000; // Convert minutes to milliseconds\n         var calculatedTime = new Date(baseTime + timeOffset);\n         return '<b>' + this.series.name + '</b><br>' +\n                'Time: ' + Highcharts.dateFormat('%Y-%m-%d %H:%M:%S UTC', calculatedTime);\n       }\"\n    )\n  )\n```\n\n### 4 employee:\n\n```{r}\n#| echo: false\narrival_data <- sim4  %>%\n  get_mon_arrivals()\n  \nlibrary(highcharter)\narrival_data |> \n  dplyr::select(c(start_time,\n           end_time,\n           activity_time)) |> \n  pivot_longer(cols = everything(),\n               values_to = \"time\",\n               names_to = \"type\") |> \n  hchart(\n  'line', \n  hcaes(y = time,\n        group = type)\n  ) |> \n   hc_tooltip(\n    pointFormat = '{point.x: %Y-%m-%d} ',\n    headerFormat = '',\n    useHTML = TRUE,\n     formatter = JS(\n      \"function() {\n         var baseTime = Date.parse('2024-11-11 08:30:00 UTC'); // Base time\n         var timeOffset = this.y * 60000; // Convert minutes to milliseconds\n         var calculatedTime = new Date(baseTime + timeOffset);\n         return '<b>' + this.series.name + '</b><br>' +\n                'Time: ' + Highcharts.dateFormat('%Y-%m-%d %H:%M:%S UTC', calculatedTime);\n       }\"\n    )\n  )\n```\n:::\n\nKết quả cho thấy cửa hàng nên thuê 4 người để đảm bảo *server level* ở dạng cao. Nếu cửa hàng chỉ thuê 2 người thì thời gian đợi phục vụ trung bình của khách hàng là khoảng **7.5 tiếng** (Một con số hơi khủng, tưởng đang sử dụng dịch vụ của Vietjet cơ! 😄😄😄) trong khi nếu thuê thêm 2 người thì giảm xuống còn **41.5 phút** \\~ giảm thời gian chờ đợi xuống **11 lần**.\n\n### Lý thuyết thống kê:\n\nTiếp theo, bạn cần lý thuyết thống kê về chuyên ngành của vấn đề mà bạn đang mong muốn mô hình hóa. Việc xác định các đối tượng trong *server* và đối tượng mục tiêu cần giả lập cũng như các đặc tính cần có trong mô hình là quan trọng bởi chúng là sườn sống của mô hình giả lập. Ví dụ như quy trình hoạt động của quán cafe là như thế nào, sẽ hoạt động ra sao trong nhiều trường hợp,... càng rõ thì việc giả lập càng sát với thực tế.\n\nĐặc biệt với các ngành về y sinh học, giả lập quần thể là công việc hằng ngày của các nghiên cứu sinh nên việc hiểu rõ bản chất của quần thể đó quan trọng hơn cách thức hay phương pháp giả lập.\n\nVề code, bạn cần lưu ý rằng *sample size - số lượng mẫu* ảnh hưởng lớn đến độ chính xác (*precision*) của đo lường ảnh hưởng của biến đó. Điều này cũng tương tự với độ lặp lại (*replication*) nghĩa là bạn lặp lại nhiều lần việc tính toán thì kết quả sẽ tốt hoặc chính xác hơn.\n\nTiếp theo, ta sẽ thực hành trong R.\n\n```{=html}\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Go to Next Page</title>\n    <style>\n        /* Global Styles */\n        body {\n            font-family: 'Tahoma', sans-serif;\n            display: flex;\n            flex-direction: column;  /* Stack content and footnote vertically */\n            justify-content: center;  /* Center content vertically */\n            align-items: center;      /* Center content horizontally */\n            margin: 0;\n            background-color: $secondary-color;\n            box-sizing: border-box;\n            min-height: 80vh; /* Adjusted to 80vh to ensure it's not too high */\n        }\n\n        /* Container Styling (Main Content) */\n        .container {\n            text-align: center;\n            padding: 20px 40px; /* Adjust padding for more compactness */\n            background-color: white;\n            border-radius: 12px;\n            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);\n            width: auto;  /* Auto width to fit content */\n            max-width: 380px;  /* Adjusted max-width for a smaller container */\n            box-sizing: border-box;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            flex-direction: column;\n            margin-top: 20px;  /* Space from the top of the page */\n        }\n\n        /* Link Styling */\n        .link {\n            font-size: 20px;  /* Adjusted font size for readability */\n            color: #007bff;\n            text-decoration: none;\n            font-weight: 700;\n            display: inline-flex;\n            align-items: center;\n            cursor: pointer;\n            padding: 12px 30px;\n            border-radius: 6px;\n            transition: all 0.3s ease;\n        }\n\n        .link:hover {\n            color: #0056b3;\n            text-decoration: none;\n            background-color: #e6f0ff;\n        }\n\n        /* Arrow Styling */\n        .arrow {\n            margin-left: 12px;\n            font-size: 24px;\n            transition: transform 0.3s ease, font-size 0.3s ease;\n        }\n\n        .link:hover .arrow {\n            transform: translateX(8px);\n            font-size: 26px;\n        }\n\n        /* Focus State for Accessibility */\n        .link:focus {\n            outline: 2px solid #0056b3;\n        }\n\n        /* Footer Styling (Footnote) */\n        .footer {\n            font-size: 14px;\n            color: #777;\n            margin-top: 20px;  /* Space between content and footnote */\n            text-align: center;\n            width: 100%;\n        }\n\n        /* Mobile-Friendly Adjustments */\n        @media (max-width: 600px) {\n            .link {\n                font-size: 18px;\n                padding: 8px 15px;  /* Smaller padding for mobile devices */\n            }\n\n            .arrow {\n                font-size: 18px;\n                margin-left: 8px;\n            }\n\n            .container {\n                padding: 15px 30px;  /* Smaller padding on mobile */\n                max-width: 90%;  /* Ensure container fits better on small screens */\n            }\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <a href=\"https://loccx78vn.github.io/Simulation_in_R/practice.html\" class=\"link\" tabindex=\"0\">\n            Go to Next Page\n            <span class=\"arrow\">➔</span>\n        </a>\n    </div>\n</body>\n</html>\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"number-sections":true,"output-file":"simulate.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.30","editor":"visual","theme":{"light":"theme-light.scss","dark":"theme-dark.scss"},"title":"Simulation","subtitle":"Việt Nam, 2024","categories":["SupplyChainManagement","Simulation","Agent Based Modeling"],"description":"Đây là bài viết của tôi về cách sử dụng R trong việc giả lập","author":"Cao Xuân Lộc","date":"2024-11-13","title-block-banner":"img/autumn.jpg","title-block-banner-color":"white","bibliography":["references.bib"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}