[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduce",
    "section": "",
    "text": "Xin chào, mình là Lộc, sinh năm 2003 và là một chàng trai đến từ mảnh đất đầy nắng và gió - Phú Yên, Việt Nam. Mình có bằng cử nhân trường Đại học Kinh Tế - Tài Chính (UEF) và chuyên ngành của mình là Logistics và quản lý chuỗi cung ứng.\nLà người có niềm đam mê mạnh mẽ với R, mình có sở thích viết post về việc phân tích dữ liệu với R để ứng dụng vào các công việc, bài toán thường gặp trong Supply Chain. Ngoài ra, sở thích của mình là nghe sách nói và đi bộ!\nCâu slogan mà mình thích nhất là: “Don’t fear the risk, fear the opportunity lost!” và đó cũng là cách mình sống và làm việc đến bây giờ 💝💝💝.\nHi vọng các bạn sẽ thích bài viết của mình!\n    \n    \n    Go to Next Page\n    \n    \n        \n            Go to Next Page\n            ➔"
  },
  {
    "objectID": "practice.html",
    "href": "practice.html",
    "title": "Practice in R",
    "section": "",
    "text": "TIếp theo là chúng ta sẽ lập thử DES trong R để giả lập quá trình duy chuyển của xe trong chuỗi cung ứng để ứng tính ETD và ETA.\nTrong R có package simmer thuần về xây dựng mô hình DES, đòi hỏi 3 nhân tố là: (i) Hành vi hoạt động của đối tượng, (ii) Hàm tính thời gian cho hoạt động và (iii) Môi trường để chạy mô phỏng. Bạn có thể đọc bài viết này để biết thêm simmerR.\n\n\n\nCác object cần có trong mô hình DES là:\n\nEntitiy: là đối tượng chính cần quan sát, ví dụ: khách hàng. Bạn sử dụng hàm add_generator() để thêm đối tượng vào mô hình.\nAttribute: là property của entity (có thể hiểu là đặc tính, trạng thái,…).\nResource: là một nguồn lực mà entity được quyền dùng, ví dụ như nhân viên quán cafe cần hỗ trợ khách hàng khi có yêu cầu. Dùng hàm add_resource() để thêm và xác định số lượng resource bằng đối số: capacity = n.\nQueue: là một chuỗi để các entity tham gia vào, ví dụ như hàng xếp chờ lấy nước ở quán cafe.\nEvent: các sự kiện thay đổi trong hệ thống.\n\nVí dụ như đoạn code dưới đây:\n\n\nCode\nlibrary(simmer)\nset.seed(1234)\n# Define the trajectory for the vehicle's process\nvehicle_traj &lt;- trajectory(\"Vehicle Process\") %&gt;%\n  # Step 1: Take Order\n  timeout(function() rnorm(n=1, mean = 30, sd = 3)) %&gt;% # Time to take an order\n  \n  # Step 2: Check if goods are available in the warehouse\n  seize(\"warehouse\", 1) %&gt;%  \n  timeout(function() rexp(1, 0.3)) %&gt;%  # Time to check if goods are available\n  release(\"warehouse\", 1) %&gt;%  # Release the warehouse resource after checking\n  \n  # Step 3: If goods are not available, wait for manufacturing (conditional)\n  branch(\n    option = function() ifelse(runif(1) &lt; 0.5, 1, 2),  # 50% chance\n    continue = c(TRUE, TRUE),\n    trajectory() %&gt;% \n      timeout(function() rexp(1, 0.8)),  # Manufacturing time if goods aren't available\n    \n    trajectory(\"WaitForStock\")  # Second branch if goods are available\n  ) %&gt;%\n  \n  # Step 4: Loading the goods\n  seize(\"truck\", 1) %&gt;%  # Seize one truck for loading\n  timeout(function() rexp(1, 0.6)) %&gt;%  # Loading time\n  release(\"truck\", 1) %&gt;%  # Release truck after loading\n  \n  # Step 5: Transport to store\n  timeout(function() rexp(1, 1)) %&gt;%  # Transport time\n  \n  # Step 6: Unload the goods at the store\n  seize(\"store\", 1) %&gt;%  # Seize one store resource for unloading\n  timeout(function() rexp(1, 0.4)) %&gt;%  # Unloading time\n  release(\"store\", 1)  # Release store resource\n\n# Create an environment\nenv &lt;- simmer(\"Vehicle Simulation\") %&gt;%\n  add_resource(\"warehouse\", capacity = 1) %&gt;%  \n  add_resource(\"truck\", capacity = 1) %&gt;%  \n  add_resource(\"store\", capacity = 1) %&gt;%  \n  \n  # Add generator for vehicles arriving with an exponential inter-arrival time\n  add_generator(\"vehicle\", vehicle_traj, function() rexp(1, 0.1))  # Average of 10 vehicles per 100 time units\n\n# Run the simulation for a longer duration\nenv %&gt;% \n  run(until = 500)\n\n\nsimmer environment: Vehicle Simulation | now: 500 | next: 506.640269258215\n{ Monitor: in memory }\n{ Resource: warehouse | monitored: TRUE | server status: 0(1) | queue status: 0(Inf) }\n{ Resource: truck | monitored: TRUE | server status: 0(1) | queue status: 0(Inf) }\n{ Resource: store | monitored: TRUE | server status: 0(1) | queue status: 0(Inf) }\n{ Source: vehicle | monitored: 1 | n_generated: 45 }\n\n\nCode\nstart_time &lt;- as.POSIXct(\"2024-11-09 08:30:00\", \n                         format=\"%Y-%m-%d %H:%M:%S\")\n\narrivals&lt;-get_mon_arrivals(env, per_resource = T)\narrivals$datetime &lt;- start_time + (arrivals$start_time * 60)  \narrivals$finish_datetime &lt;- start_time + (arrivals$end_time * 60)  \n\n\nThông tin từ R được xuất ra cho thấy thời gian chạy là 500 và có 45 xe đã di chuyển vào hệ thống. Kết quả giả lập được thể hiện như sau: các đốm thể hiện thời điểm xe đi vào, chờ giải quyết yêu cầu và đi ra khỏi hàng chờ.\n\n\n\nBiểu đồ 1: Discrete Event Simulation\n\n\nVà chúng ta sẽ có final output gồm:\n\n\n\n\n\nCode\nlibrary(simmer.plot)\nresources &lt;- get_mon_resources(env)\nplot(resources, \n     metric = \"usage\",\n     c(\"warehouse\", \"truck\",\"store\"),\n     items = \"server\")\n\n\n\n\n\nBiểu đồ 2: Quy trình di chuyển giả lập của xe\n\n\n\n\n\n\n\n\n\nCode\nlibrary(highcharter)\narrivals |&gt; \n  dplyr::select(c(start_time,\n           end_time,\n           activity_time)) |&gt; \n  pivot_longer(cols = everything(),\n               values_to = \"time\",\n               names_to = \"type\") |&gt; \nhchart(\n  'line', \n  hcaes(y = time,\n        group = type)\n  ) \n\n\n\n\nBiểu đồ 3: Thời gian giả lập của xe\n\n\n\n\n\n\n\nKhác với DES, ABM quan tâm nhiều hơn đến các đặc tính, thông tin của cá thể trong quần thể này. Do đó, chỉ với lượng thông tin về số xe, số nhà kho, số cửa hàng và quy trình hoạt động là chưa đủ để xây dựng mô hình ABM. Các dữ liệu khả thi có thể bao gồm: thông tin của đội xe: gồm bao nhiêu người hoặc gồm những ai; dữ liệu quá khứ về KPI, học vấn,…; thông tin về thời gian hoạt động của các cửa hàng; vị trí và thông tin về đường xá có cấm tải không;… ABM thường được ứng dụng vào việc xác định các risks - rủi ro trong quản lí chuỗi cung ứng\nTrong R có thư viện NetLogoR hỗ trợ chúng ta tốt về mảng mô hình ABM. Về nền tảng, ABM cần các yếu tố cơ bản sau:\n\nAgents: là cá thể hoạt động trong môi trường giả lập, có thể là con người, xe cộ, …\nWorld: Môi trường mà các agent “sống” bên trong.\nSet of rules: Những luật lệ mà tất cả agent “sống”trong world phải tuân theo.\nLoop: Là sự lặp đi lặp lại của các hoạt động, sự tương tác. Trong lập trình thì nó giống như vòng lặp for if quen thuộc còn trong đời thực như cuộc sống hằng ngày của bạn sẽ được lặp đi lặp lại ví dụ: sáng thì đi học, tối thì đi ngủ và có thể có các đột biến như: sáng nay được nghỉ học, tối thứ 7 thì thức cả đêm (Đây lại là hoạt động quen thuộc của tôi!!!).\n\nNhư vậy, bạn có thể hình dung mơ hồ về quần thể giả lập bao gồm: các chiếc xe, các nodes trong supply chain như: nhà kho, cửa hàng,…\n\n\n\nBiểu đồ 4: Simple of Agent Based Modeling\n\n\nNhư trên đây là ví dụ về cách simulation cho 1 đối tượng di chuyển trong mặt phẳng 10x10. Đối tượng sẽ di chuyển mỗi lần 1 ô với 4 hướng di chuyển: “up”,“down”,“left”,“right” và được chọn hướng random. Kết quả sau 50 bước thì đối tượng đã di chuyển đến điểm dropoff.\nDưới đây là một ví dụ phức tạp hơn về giả lập thời gian di chuyển dự kiến của xe với các đặc điểm sau:\n\nNhận thông tin xe: thời gian sẽ random từ 8h30 đến 9h.\nGọi xe: Việc này sẽ hoàn thành trong 15 phút.\nXe di chuyển đến điểm pickup: Tính thời gian di chuyển bằng transportation time = distance/average speed cộng với thời gian loading time = 30'.\nXe di chuyển đến điểm dropoff: Tính thời gian di chuyển bằng transportation time = distance/average speed cộng với thời gian unloading time = 40'.\n\nKết quả giả lập cho 5 xe như sau:\n\n\nCode\nlibrary(NetLogoR)\nlibrary(lubridate)\nlibrary(tidyverse)\n\n# Define new time parameters for the extended simulation\nn_vehicles &lt;- 5              # Number of vehicles\ngrid_size &lt;- 20              # Size of the grid\nspeed_limit &lt;- 2             # Speed limit (cells per tick)\ntime_step &lt;- 1               # Simulation time step (1 second per tick)\norder_creation_time &lt;- c(hm(\"8:30\"), hm(\"9:00\"))   # Time when orders are released (8:30 AM)\nn_customer &lt;- 5\n\nn_ticks &lt;- 48  # Increase simulation time\n\n# Initialize the world, orders, and vehicle positions\nworld &lt;- createWorld(minPxcor = -grid_size, \n                     maxPxcor = grid_size, \n                     minPycor = -grid_size, \n                     maxPycor = grid_size)\n\nrandom_coords &lt;- randomXYcor(world, n = n_vehicles)\n\n# Define orders and vehicles\norders &lt;- data.frame(\n  order_id = 1:n_customer,\n  pickup_x = sample(1:grid_size, n_customer, replace = TRUE),\n  pickup_y = sample(1:grid_size, n_customer, replace = TRUE),\n  dropoff_x = sample(1:grid_size, n_customer, replace = TRUE),\n  dropoff_y = sample(1:grid_size, n_customer, replace = TRUE),\n  order_time = as.POSIXct(\"08:30:00\", format = \"%H:%M:%S\") + runif(n_customer, 0, 1800)\n)\n\n# Initialize vehicles' position and speed\nvehicles_df &lt;- data.frame(\n  vehicle_id = 1:n_vehicles,\n  xcor = random_coords[, 1],\n  ycor = random_coords[, 2],\n  speed = rep(1.5, n_vehicles)\n)\n\n# Initialize tracking variables\nvehicle_order &lt;- rep(NA, n_vehicles)\norder_status &lt;- rep(NA, n_customer)\nvehicle_state &lt;- rep(\"waiting\", n_vehicles)  # New: track state of each vehicle\nETA &lt;- rep(NA, n_vehicles)  # Initialize ETA for each vehicle\nETD &lt;- rep(NA, n_vehicles)  # Initialize ETD for each vehicle\ncompleted_time &lt;- rep(NA, n_vehicles)  # Initialize completed time for each vehicle\n\n# Function to simulate vehicle movement (with speed and direction)\nmove_vehicle &lt;- function(vehicle, destination) {\n  angle_to_dest &lt;- atan2(destination[2] - vehicle$ycor, destination[1] - vehicle$xcor)\n  distance_to_dest &lt;- sqrt((vehicle$xcor - destination[1])^2 + (vehicle$ycor - destination[2])^2)\n  \n  # Move the vehicle\n  distance_to_move &lt;- min(distance_to_dest, vehicle$speed)\n  vehicle$xcor &lt;- vehicle$xcor + distance_to_move * cos(angle_to_dest)\n  vehicle$ycor &lt;- vehicle$ycor + distance_to_move * sin(angle_to_dest)\n  \n  return(vehicle)\n}\n\n# Function to calculate the distance between two points\ncalculate_distance &lt;- function(x1, y1, x2, y2) {\n  return(sqrt((x1 - x2)^2 + (y1 - y2)^2))\n}\n\n# Function to check if a vehicle is at a location (pickup/dropoff)\nat_location &lt;- function(vehicle, location) {\n  return(abs(vehicle$xcor - location[1]) &lt; 0.5 && abs(vehicle$ycor - location[2]) &lt; 0.5)\n}\n\nsimulation_start_time &lt;- as.POSIXct(\"08:00:00\", format = \"%H:%M:%S\")\n\n# Initialize an empty data frame to store the results\nfinal_results &lt;- data.frame()\n\n# Simulation loop with updated conditions\nfor (tick in 1:n_ticks) {\n  current_time &lt;- simulation_start_time + seconds(tick) * 3600 / 2\n  \n  # Process each vehicle\n  for (i in 1:n_vehicles) {\n    if (is.na(vehicle_order[i])) {  \n      # Assign a vehicle to an order if it's free and an order is available\n      for (j in 1:nrow(orders)) {\n        if (is.na(order_status[j]) && current_time &gt;= orders$order_time[j]) {\n          order_status[j] &lt;- \"in_progress\"  # Change order status to in_progress\n          vehicle_order[i] &lt;- j\n          vehicle_state[i] &lt;- \"received\"  # Vehicle starts receiving the order\n          \n          # Calculate ETA (time to reach pickup location)\n          distance_to_pickup &lt;- calculate_distance(vehicles_df$xcor[i], vehicles_df$ycor[i], \n                                                   orders$pickup_x[j], orders$pickup_y[j])\n          transportation_time &lt;- distance_to_pickup / vehicles_df$speed[i]  # Time to pickup location in hours\n          ETA[i] &lt;- orders$order_time[j] + seconds(transportation_time) * 3600  # ETA in POSIXct object\n          \n          break\n        }\n      }\n    }\n    \n    # Get current order info for the assigned order\n    assigned_order &lt;- vehicle_order[i]\n    \n    if (!is.na(assigned_order)) {\n      pickup_loc &lt;- c(orders$pickup_x[assigned_order], orders$pickup_y[assigned_order])\n      dropoff_loc &lt;- c(orders$dropoff_x[assigned_order], orders$dropoff_y[assigned_order])\n      \n      # Handle movement to pickup location\n      if (vehicle_state[i] == \"received\") {\n        if (!at_location(vehicles_df[i, ], pickup_loc)) {\n          vehicles_df[i, ] &lt;- move_vehicle(vehicles_df[i, ], pickup_loc)\n        } else {\n          vehicle_state[i] &lt;- \"loading\"  # Transition to loading state\n        }\n      }\n      \n      # Handle loading phase (vehicle at pickup location)\n      if (vehicle_state[i] == \"loading\") {\n        if (at_location(vehicles_df[i, ], pickup_loc)) {\n          vehicle_state[i] &lt;- \"enroute\"  # Transition to enroute state\n          \n          # Calculate the transportation time to dropoff location\n          distance_to_dropoff &lt;- calculate_distance(vehicles_df$xcor[i], vehicles_df$ycor[i], \n                                                   dropoff_loc[1], dropoff_loc[2])\n          transportation_time &lt;- distance_to_dropoff / vehicles_df$speed[i]\n          ETD[i] &lt;- ETA[i] + seconds(transportation_time*3600 + 30*60)   # Add transportation time to dropoff location\n        }\n      }\n      \n      # Handle enroute phase (vehicle moving to dropoff location)\n      if (vehicle_state[i] == \"enroute\") {\n        if (!at_location(vehicles_df[i, ], dropoff_loc)) {\n          vehicles_df[i, ] &lt;- move_vehicle(vehicles_df[i, ], dropoff_loc)\n        } else {\n          vehicle_state[i] &lt;- \"completed\"  # Transition to completed state\n          \n          # Set completed time (ETD + unloading time 40 minutes)\n          completed_time[i] &lt;- ETD[i] + seconds(40*60)  # Unloading time 40 minutes\n        }\n      }\n      \n      # Handle unloading phase (vehicle at dropoff location)\n      if (vehicle_state[i] == \"completed\") {\n        order_status[assigned_order] &lt;- \"completed\"\n      }\n    }\n  }\n  \n  # Store the current simulation results with time info\n  tick_result &lt;- data.frame(\n    time = current_time,\n    vehicle_id = 1:n_vehicles,\n    xcor = vehicles_df$xcor,\n    ycor = vehicles_df$ycor,\n    speed = vehicles_df$speed,\n    order_status = order_status,\n    vehicle_order = vehicle_order,\n    vehicle_state = vehicle_state,  # Track vehicle state\n    ETA = ETA,  # Estimated Time of Arrival\n    ETD = ETD,  # Estimated Time of Departure\n    completed_time = completed_time  # Completed Time\n  ) \n  \n  # Append the current results to the final_results data frame\n  final_results &lt;- bind_rows(final_results, tick_result)\n}\n\nfinal_results &lt;- final_results|&gt; \n  filter(!is.na(order_status)) |&gt; \n    mutate(ETA = as.POSIXct(ETA, origin = \"1970-01-01\", tz = \"UTC\"),\n           ETD = as.POSIXct(ETD, origin = \"1970-01-01\", tz = \"UTC\"),\n           completed_time = as.POSIXct(completed_time, origin = \"1970-01-01\", tz = \"UTC\"))\n\nfinal&lt;-final_results[!duplicated(final_results[, setdiff(names(final_results), \"time\")]), ]\n\n\n\n\n\nBiểu đồ 5: Agent Based Modeling\n\n\nKết quả cho thấy xe 1 và xe 2 có khả năng trễ chuyến nên cần lưu ý và hỗ trợ tài xế để đảm bảo xe đến đúng giờ hành chính. Như vậy chúng ta đã kết thúc bài học ở đây."
  },
  {
    "objectID": "practice.html#thực-hành-trong-r",
    "href": "practice.html#thực-hành-trong-r",
    "title": "Practice in R",
    "section": "",
    "text": "TIếp theo là chúng ta sẽ lập thử DES trong R để giả lập quá trình duy chuyển của xe trong chuỗi cung ứng để ứng tính ETD và ETA.\nTrong R có package simmer thuần về xây dựng mô hình DES, đòi hỏi 3 nhân tố là: (i) Hành vi hoạt động của đối tượng, (ii) Hàm tính thời gian cho hoạt động và (iii) Môi trường để chạy mô phỏng. Bạn có thể đọc bài viết này để biết thêm simmerR.\n\n\n\nCác object cần có trong mô hình DES là:\n\nEntitiy: là đối tượng chính cần quan sát, ví dụ: khách hàng. Bạn sử dụng hàm add_generator() để thêm đối tượng vào mô hình.\nAttribute: là property của entity (có thể hiểu là đặc tính, trạng thái,…).\nResource: là một nguồn lực mà entity được quyền dùng, ví dụ như nhân viên quán cafe cần hỗ trợ khách hàng khi có yêu cầu. Dùng hàm add_resource() để thêm và xác định số lượng resource bằng đối số: capacity = n.\nQueue: là một chuỗi để các entity tham gia vào, ví dụ như hàng xếp chờ lấy nước ở quán cafe.\nEvent: các sự kiện thay đổi trong hệ thống.\n\nVí dụ như đoạn code dưới đây:\n\n\nCode\nlibrary(simmer)\nset.seed(1234)\n# Define the trajectory for the vehicle's process\nvehicle_traj &lt;- trajectory(\"Vehicle Process\") %&gt;%\n  # Step 1: Take Order\n  timeout(function() rnorm(n=1, mean = 30, sd = 3)) %&gt;% # Time to take an order\n  \n  # Step 2: Check if goods are available in the warehouse\n  seize(\"warehouse\", 1) %&gt;%  \n  timeout(function() rexp(1, 0.3)) %&gt;%  # Time to check if goods are available\n  release(\"warehouse\", 1) %&gt;%  # Release the warehouse resource after checking\n  \n  # Step 3: If goods are not available, wait for manufacturing (conditional)\n  branch(\n    option = function() ifelse(runif(1) &lt; 0.5, 1, 2),  # 50% chance\n    continue = c(TRUE, TRUE),\n    trajectory() %&gt;% \n      timeout(function() rexp(1, 0.8)),  # Manufacturing time if goods aren't available\n    \n    trajectory(\"WaitForStock\")  # Second branch if goods are available\n  ) %&gt;%\n  \n  # Step 4: Loading the goods\n  seize(\"truck\", 1) %&gt;%  # Seize one truck for loading\n  timeout(function() rexp(1, 0.6)) %&gt;%  # Loading time\n  release(\"truck\", 1) %&gt;%  # Release truck after loading\n  \n  # Step 5: Transport to store\n  timeout(function() rexp(1, 1)) %&gt;%  # Transport time\n  \n  # Step 6: Unload the goods at the store\n  seize(\"store\", 1) %&gt;%  # Seize one store resource for unloading\n  timeout(function() rexp(1, 0.4)) %&gt;%  # Unloading time\n  release(\"store\", 1)  # Release store resource\n\n# Create an environment\nenv &lt;- simmer(\"Vehicle Simulation\") %&gt;%\n  add_resource(\"warehouse\", capacity = 1) %&gt;%  \n  add_resource(\"truck\", capacity = 1) %&gt;%  \n  add_resource(\"store\", capacity = 1) %&gt;%  \n  \n  # Add generator for vehicles arriving with an exponential inter-arrival time\n  add_generator(\"vehicle\", vehicle_traj, function() rexp(1, 0.1))  # Average of 10 vehicles per 100 time units\n\n# Run the simulation for a longer duration\nenv %&gt;% \n  run(until = 500)\n\n\nsimmer environment: Vehicle Simulation | now: 500 | next: 506.640269258215\n{ Monitor: in memory }\n{ Resource: warehouse | monitored: TRUE | server status: 0(1) | queue status: 0(Inf) }\n{ Resource: truck | monitored: TRUE | server status: 0(1) | queue status: 0(Inf) }\n{ Resource: store | monitored: TRUE | server status: 0(1) | queue status: 0(Inf) }\n{ Source: vehicle | monitored: 1 | n_generated: 45 }\n\n\nCode\nstart_time &lt;- as.POSIXct(\"2024-11-09 08:30:00\", \n                         format=\"%Y-%m-%d %H:%M:%S\")\n\narrivals&lt;-get_mon_arrivals(env, per_resource = T)\narrivals$datetime &lt;- start_time + (arrivals$start_time * 60)  \narrivals$finish_datetime &lt;- start_time + (arrivals$end_time * 60)  \n\n\nThông tin từ R được xuất ra cho thấy thời gian chạy là 500 và có 45 xe đã di chuyển vào hệ thống. Kết quả giả lập được thể hiện như sau: các đốm thể hiện thời điểm xe đi vào, chờ giải quyết yêu cầu và đi ra khỏi hàng chờ.\n\n\n\nBiểu đồ 1: Discrete Event Simulation\n\n\nVà chúng ta sẽ có final output gồm:\n\n\n\n\n\nCode\nlibrary(simmer.plot)\nresources &lt;- get_mon_resources(env)\nplot(resources, \n     metric = \"usage\",\n     c(\"warehouse\", \"truck\",\"store\"),\n     items = \"server\")\n\n\n\n\n\nBiểu đồ 2: Quy trình di chuyển giả lập của xe\n\n\n\n\n\n\n\n\n\nCode\nlibrary(highcharter)\narrivals |&gt; \n  dplyr::select(c(start_time,\n           end_time,\n           activity_time)) |&gt; \n  pivot_longer(cols = everything(),\n               values_to = \"time\",\n               names_to = \"type\") |&gt; \nhchart(\n  'line', \n  hcaes(y = time,\n        group = type)\n  ) \n\n\n\n\nBiểu đồ 3: Thời gian giả lập của xe\n\n\n\n\n\n\n\nKhác với DES, ABM quan tâm nhiều hơn đến các đặc tính, thông tin của cá thể trong quần thể này. Do đó, chỉ với lượng thông tin về số xe, số nhà kho, số cửa hàng và quy trình hoạt động là chưa đủ để xây dựng mô hình ABM. Các dữ liệu khả thi có thể bao gồm: thông tin của đội xe: gồm bao nhiêu người hoặc gồm những ai; dữ liệu quá khứ về KPI, học vấn,…; thông tin về thời gian hoạt động của các cửa hàng; vị trí và thông tin về đường xá có cấm tải không;… ABM thường được ứng dụng vào việc xác định các risks - rủi ro trong quản lí chuỗi cung ứng\nTrong R có thư viện NetLogoR hỗ trợ chúng ta tốt về mảng mô hình ABM. Về nền tảng, ABM cần các yếu tố cơ bản sau:\n\nAgents: là cá thể hoạt động trong môi trường giả lập, có thể là con người, xe cộ, …\nWorld: Môi trường mà các agent “sống” bên trong.\nSet of rules: Những luật lệ mà tất cả agent “sống”trong world phải tuân theo.\nLoop: Là sự lặp đi lặp lại của các hoạt động, sự tương tác. Trong lập trình thì nó giống như vòng lặp for if quen thuộc còn trong đời thực như cuộc sống hằng ngày của bạn sẽ được lặp đi lặp lại ví dụ: sáng thì đi học, tối thì đi ngủ và có thể có các đột biến như: sáng nay được nghỉ học, tối thứ 7 thì thức cả đêm (Đây lại là hoạt động quen thuộc của tôi!!!).\n\nNhư vậy, bạn có thể hình dung mơ hồ về quần thể giả lập bao gồm: các chiếc xe, các nodes trong supply chain như: nhà kho, cửa hàng,…\n\n\n\nBiểu đồ 4: Simple of Agent Based Modeling\n\n\nNhư trên đây là ví dụ về cách simulation cho 1 đối tượng di chuyển trong mặt phẳng 10x10. Đối tượng sẽ di chuyển mỗi lần 1 ô với 4 hướng di chuyển: “up”,“down”,“left”,“right” và được chọn hướng random. Kết quả sau 50 bước thì đối tượng đã di chuyển đến điểm dropoff.\nDưới đây là một ví dụ phức tạp hơn về giả lập thời gian di chuyển dự kiến của xe với các đặc điểm sau:\n\nNhận thông tin xe: thời gian sẽ random từ 8h30 đến 9h.\nGọi xe: Việc này sẽ hoàn thành trong 15 phút.\nXe di chuyển đến điểm pickup: Tính thời gian di chuyển bằng transportation time = distance/average speed cộng với thời gian loading time = 30'.\nXe di chuyển đến điểm dropoff: Tính thời gian di chuyển bằng transportation time = distance/average speed cộng với thời gian unloading time = 40'.\n\nKết quả giả lập cho 5 xe như sau:\n\n\nCode\nlibrary(NetLogoR)\nlibrary(lubridate)\nlibrary(tidyverse)\n\n# Define new time parameters for the extended simulation\nn_vehicles &lt;- 5              # Number of vehicles\ngrid_size &lt;- 20              # Size of the grid\nspeed_limit &lt;- 2             # Speed limit (cells per tick)\ntime_step &lt;- 1               # Simulation time step (1 second per tick)\norder_creation_time &lt;- c(hm(\"8:30\"), hm(\"9:00\"))   # Time when orders are released (8:30 AM)\nn_customer &lt;- 5\n\nn_ticks &lt;- 48  # Increase simulation time\n\n# Initialize the world, orders, and vehicle positions\nworld &lt;- createWorld(minPxcor = -grid_size, \n                     maxPxcor = grid_size, \n                     minPycor = -grid_size, \n                     maxPycor = grid_size)\n\nrandom_coords &lt;- randomXYcor(world, n = n_vehicles)\n\n# Define orders and vehicles\norders &lt;- data.frame(\n  order_id = 1:n_customer,\n  pickup_x = sample(1:grid_size, n_customer, replace = TRUE),\n  pickup_y = sample(1:grid_size, n_customer, replace = TRUE),\n  dropoff_x = sample(1:grid_size, n_customer, replace = TRUE),\n  dropoff_y = sample(1:grid_size, n_customer, replace = TRUE),\n  order_time = as.POSIXct(\"08:30:00\", format = \"%H:%M:%S\") + runif(n_customer, 0, 1800)\n)\n\n# Initialize vehicles' position and speed\nvehicles_df &lt;- data.frame(\n  vehicle_id = 1:n_vehicles,\n  xcor = random_coords[, 1],\n  ycor = random_coords[, 2],\n  speed = rep(1.5, n_vehicles)\n)\n\n# Initialize tracking variables\nvehicle_order &lt;- rep(NA, n_vehicles)\norder_status &lt;- rep(NA, n_customer)\nvehicle_state &lt;- rep(\"waiting\", n_vehicles)  # New: track state of each vehicle\nETA &lt;- rep(NA, n_vehicles)  # Initialize ETA for each vehicle\nETD &lt;- rep(NA, n_vehicles)  # Initialize ETD for each vehicle\ncompleted_time &lt;- rep(NA, n_vehicles)  # Initialize completed time for each vehicle\n\n# Function to simulate vehicle movement (with speed and direction)\nmove_vehicle &lt;- function(vehicle, destination) {\n  angle_to_dest &lt;- atan2(destination[2] - vehicle$ycor, destination[1] - vehicle$xcor)\n  distance_to_dest &lt;- sqrt((vehicle$xcor - destination[1])^2 + (vehicle$ycor - destination[2])^2)\n  \n  # Move the vehicle\n  distance_to_move &lt;- min(distance_to_dest, vehicle$speed)\n  vehicle$xcor &lt;- vehicle$xcor + distance_to_move * cos(angle_to_dest)\n  vehicle$ycor &lt;- vehicle$ycor + distance_to_move * sin(angle_to_dest)\n  \n  return(vehicle)\n}\n\n# Function to calculate the distance between two points\ncalculate_distance &lt;- function(x1, y1, x2, y2) {\n  return(sqrt((x1 - x2)^2 + (y1 - y2)^2))\n}\n\n# Function to check if a vehicle is at a location (pickup/dropoff)\nat_location &lt;- function(vehicle, location) {\n  return(abs(vehicle$xcor - location[1]) &lt; 0.5 && abs(vehicle$ycor - location[2]) &lt; 0.5)\n}\n\nsimulation_start_time &lt;- as.POSIXct(\"08:00:00\", format = \"%H:%M:%S\")\n\n# Initialize an empty data frame to store the results\nfinal_results &lt;- data.frame()\n\n# Simulation loop with updated conditions\nfor (tick in 1:n_ticks) {\n  current_time &lt;- simulation_start_time + seconds(tick) * 3600 / 2\n  \n  # Process each vehicle\n  for (i in 1:n_vehicles) {\n    if (is.na(vehicle_order[i])) {  \n      # Assign a vehicle to an order if it's free and an order is available\n      for (j in 1:nrow(orders)) {\n        if (is.na(order_status[j]) && current_time &gt;= orders$order_time[j]) {\n          order_status[j] &lt;- \"in_progress\"  # Change order status to in_progress\n          vehicle_order[i] &lt;- j\n          vehicle_state[i] &lt;- \"received\"  # Vehicle starts receiving the order\n          \n          # Calculate ETA (time to reach pickup location)\n          distance_to_pickup &lt;- calculate_distance(vehicles_df$xcor[i], vehicles_df$ycor[i], \n                                                   orders$pickup_x[j], orders$pickup_y[j])\n          transportation_time &lt;- distance_to_pickup / vehicles_df$speed[i]  # Time to pickup location in hours\n          ETA[i] &lt;- orders$order_time[j] + seconds(transportation_time) * 3600  # ETA in POSIXct object\n          \n          break\n        }\n      }\n    }\n    \n    # Get current order info for the assigned order\n    assigned_order &lt;- vehicle_order[i]\n    \n    if (!is.na(assigned_order)) {\n      pickup_loc &lt;- c(orders$pickup_x[assigned_order], orders$pickup_y[assigned_order])\n      dropoff_loc &lt;- c(orders$dropoff_x[assigned_order], orders$dropoff_y[assigned_order])\n      \n      # Handle movement to pickup location\n      if (vehicle_state[i] == \"received\") {\n        if (!at_location(vehicles_df[i, ], pickup_loc)) {\n          vehicles_df[i, ] &lt;- move_vehicle(vehicles_df[i, ], pickup_loc)\n        } else {\n          vehicle_state[i] &lt;- \"loading\"  # Transition to loading state\n        }\n      }\n      \n      # Handle loading phase (vehicle at pickup location)\n      if (vehicle_state[i] == \"loading\") {\n        if (at_location(vehicles_df[i, ], pickup_loc)) {\n          vehicle_state[i] &lt;- \"enroute\"  # Transition to enroute state\n          \n          # Calculate the transportation time to dropoff location\n          distance_to_dropoff &lt;- calculate_distance(vehicles_df$xcor[i], vehicles_df$ycor[i], \n                                                   dropoff_loc[1], dropoff_loc[2])\n          transportation_time &lt;- distance_to_dropoff / vehicles_df$speed[i]\n          ETD[i] &lt;- ETA[i] + seconds(transportation_time*3600 + 30*60)   # Add transportation time to dropoff location\n        }\n      }\n      \n      # Handle enroute phase (vehicle moving to dropoff location)\n      if (vehicle_state[i] == \"enroute\") {\n        if (!at_location(vehicles_df[i, ], dropoff_loc)) {\n          vehicles_df[i, ] &lt;- move_vehicle(vehicles_df[i, ], dropoff_loc)\n        } else {\n          vehicle_state[i] &lt;- \"completed\"  # Transition to completed state\n          \n          # Set completed time (ETD + unloading time 40 minutes)\n          completed_time[i] &lt;- ETD[i] + seconds(40*60)  # Unloading time 40 minutes\n        }\n      }\n      \n      # Handle unloading phase (vehicle at dropoff location)\n      if (vehicle_state[i] == \"completed\") {\n        order_status[assigned_order] &lt;- \"completed\"\n      }\n    }\n  }\n  \n  # Store the current simulation results with time info\n  tick_result &lt;- data.frame(\n    time = current_time,\n    vehicle_id = 1:n_vehicles,\n    xcor = vehicles_df$xcor,\n    ycor = vehicles_df$ycor,\n    speed = vehicles_df$speed,\n    order_status = order_status,\n    vehicle_order = vehicle_order,\n    vehicle_state = vehicle_state,  # Track vehicle state\n    ETA = ETA,  # Estimated Time of Arrival\n    ETD = ETD,  # Estimated Time of Departure\n    completed_time = completed_time  # Completed Time\n  ) \n  \n  # Append the current results to the final_results data frame\n  final_results &lt;- bind_rows(final_results, tick_result)\n}\n\nfinal_results &lt;- final_results|&gt; \n  filter(!is.na(order_status)) |&gt; \n    mutate(ETA = as.POSIXct(ETA, origin = \"1970-01-01\", tz = \"UTC\"),\n           ETD = as.POSIXct(ETD, origin = \"1970-01-01\", tz = \"UTC\"),\n           completed_time = as.POSIXct(completed_time, origin = \"1970-01-01\", tz = \"UTC\"))\n\nfinal&lt;-final_results[!duplicated(final_results[, setdiff(names(final_results), \"time\")]), ]\n\n\n\n\n\nBiểu đồ 5: Agent Based Modeling\n\n\nKết quả cho thấy xe 1 và xe 2 có khả năng trễ chuyến nên cần lưu ý và hỗ trợ tài xế để đảm bảo xe đến đúng giờ hành chính. Như vậy chúng ta đã kết thúc bài học ở đây."
  },
  {
    "objectID": "practice.html#kết-luận",
    "href": "practice.html#kết-luận",
    "title": "Practice in R",
    "section": "2 Kết luận:",
    "text": "2 Kết luận:\nNếu bạn có câu hỏi hay thắc mắc nào, đừng ngần ngại liên hệ với mình qua Gmail. Bên cạnh đó, nếu bạn muốn xem lại các bài viết trước đây của mình, hãy nhấn vào hai nút dưới đây để truy cập trang Rpubs hoặc mã nguồn trên Github. Rất vui được đồng hành cùng bạn, hẹn gặp lại! 😄😄😄\n\n\n\n    \n    \n    Contact Me\n    \n    \n    \n\n\n    \n        Contact Me\n        \n            Your Email:\n            \n            Please enter a valid email address.\n            Send Email\n        \n        \n            \n                \n                     View Code on GitHub\n                \n            \n        \n        \n            \n                \n                     Visit my RPubs"
  },
  {
    "objectID": "simulate.html",
    "href": "simulate.html",
    "title": "Simulation",
    "section": "",
    "text": "Hôm nay chúng ta sẽ qua 1 phần khác trong Supply chain management đó là: giả lập (simulation)."
  },
  {
    "objectID": "simulate.html#tổng-quát",
    "href": "simulate.html#tổng-quát",
    "title": "Simulation",
    "section": "1 Tổng quát:",
    "text": "1 Tổng quát:\n\n1.1 Định nghĩa:\nSimulation - giả lập là một kĩ thuật máy tính nhằm tạo ra dữ liệu một cách ngẫu nhiên và dựa vào đó dự đoán quá trình phát triển, hoạt động của một sự vật, hiện tượng trong một đơn vị thời gian. Mục đích nhằm đánh giá mức độ hiệu quả của các giải pháp cho vấn đề, rủi ro trong tương lai.\nVí dụ giả lập mà bạn gặp thường ngày như dự báo thời tiết hay dự báo tình trạng lũ lụt, sạt lở trong thời gian mưa bão. Gần đây nhất là mô hình dự đoán số ca mắc Covid-19 nhằm đánh giá mức độ lây nhiễm ở các khu vực như ảnh dưới đây là kết quả dự báo ở Mỹ.\n\n  \n  \n  \n  \n    Hình 1: Mô hình giả lập số lượng người bị nhiễm Covid-19\n  \n  \n  \n  \n    Source: Link to Image\n  \n\nThực chất nhiều đánh giá cho rằng các mô hình dự báo Covid-19 đều thất bại, tốn thời gian mà chẳng đưa ra insight gì đáng giá. Nhưng luôn nhớ rằng “All models are wrong but some are useful” - George Box nghĩa là mọi mô hình đều có sự sai lệch và nhiệm vụ của bạn là tìm ra mô hình phù hợp nhất và tạo ra giá trị trong đời thực.\nCác lợi ích của việc simulation là:\n\nKiểm tra trực giác thống kê hoặc minh họa các đặc tính toán học mà bạn không thể dễ dàng dự đoán. Ví dụ: Kiểm tra xem liệu có hơn 5% tác động có ý nghĩa đối với một biến trong mô hình khi dữ liệu giả ngẫu nhiên được tạo ra.\nHiểu lý thuyết mẫu và phân phối xác suất hoặc kiểm tra xem bạn có hiểu các quá trình cơ bản của hệ thống của mình hay không. Ví dụ: Xem liệu dữ liệu mô phỏng lấy từ các phân phối cụ thể có thể so sánh với dữ liệu thực tế hay không.\nThực hiện phân tích độ mạnh của mẫu. Ví dụ: Đánh giá xem kích thước mẫu (trong mỗi lần lặp của mô phỏng) có đủ lớn để phát hiện tác động mô phỏng trong hơn 80% các trường hợp hay không.\nChuẩn bị kế hoạch phân tích trước. Để tự tin về các phân tích thống kê (xác nhận) mà bạn muốn thực hiện trước khi thu thập dữ liệu (ví dụ: thông qua việc đăng ký trước hoặc báo cáo đã đăng ký), việc thực hành các phân tích trên một bộ dữ liệu mô phỏng là rất hữu ích! Nếu bạn vẫn chưa chắc chắn về bài kiểm tra thống kê phù hợp nhất để áp dụng cho dữ liệu của mình, việc cung cấp bộ dữ liệu mô phỏng cho một nhà thống kê hoặc người hướng dẫn sẽ giúp họ đưa ra các gợi ý cụ thể! Mã nguồn chứa các phân tích dữ liệu mô phỏng có thể được nộp cùng với việc đăng ký trước hoặc báo cáo đã đăng ký để các nhà phản biện hiểu rõ chính xác các phân tích bạn dự định thực hiện. Khi bạn có dữ liệu thực tế, bạn chỉ cần cắm chúng vào mã này và ngay lập tức có kết quả của các phân tích xác nhận!\n\n\n\n1.2 Phân loại:\nTheo lịch sự phát triển, simulation có thể được chia thành các phân lớp như sau:\n\n  \n  \n  \n  \n    Hình 2: Phân nhánh của simulation\n  \n  \n  \n  \n    Source: Link to Image\n  \n\nTrong đó:\n\n2 nhánh lớn là Deterministic vs Stochastic: sự khác nhau rõ ràng nhất chính là outcome của 2 mô hình này. Đối với Deterministic thì outcome hoàn toàn dự đoán được, ví dụ với 1 lượng thông tin đầu vào như hình dạng tay chân, kích thước, màu sắc,… thì kết quả cuối cùng là phân biệt được đâu là hình ảnh của con chó hoặc con mèo và quan trọng là không có randomness từ mô hình - nghĩa là kết quả chỉ có là con chó hoặc con mèo. Còn với Stochastic thì thông tin đầu vào sẽ không rõ ràng như Deterministic - có thể là do sai lệch từ việc đo lường hoặc do chưa đủ thông tin nên outcome của nó cũng nằm trong 1 khoảng hoặc 1 tập hợp các giá trị khả thi.\n2 nhánh nhỏ là Static vs Dynamic: mô hình Static thì diễn tả một quá trình mô phỏng tại 1 điểm, 1 mốc thời gian cụ thể và mô hình Dynamic cũng diễn tả như vậy nhưng quá trình mô phỏng thay đổi theo thời gian. Tiêu biểu của Static là phương pháp Monte Carlo dựa trên nền tảng về random sampling."
  },
  {
    "objectID": "simulate.html#các-mô-hình-thông-dụng-trong-supply-chain-simulation",
    "href": "simulate.html#các-mô-hình-thông-dụng-trong-supply-chain-simulation",
    "title": "Simulation",
    "section": "2 Các mô hình thông dụng trong Supply Chain Simulation:",
    "text": "2 Các mô hình thông dụng trong Supply Chain Simulation:\nỨng dụng của Simulation trong Supply chain là rất nhiều, đặc biệt ở phân mảng planning. Việc giả lập trước các trường hợp, tình huống có thể gặp phải là quan trọng và nó giúp người quản lí đưa ra được các phương án thay thế hoặc phương án backup để đảm bảo chuỗi cung ứng hoạt động bình thường.\nRiêng trong ngành Supply Chain thì các mô hình được sử dụng nhiều nhất bao gồm: DES - Discrete Event Simulation và ABM - Agent Based Modeling.\n\n  \n  \n  \n  \n    Hình 3: Các mô hình phổ biến trong ngành Supply Chain\n  \n  \n  \n  \n    Source: Link to Image\n  \n\n\nDES: hướng tới mô hình hóa quy trình hoạt động của đối tượng, tựa như flowchart của process mà bạn có thể học trong quản trị vận hành. Ví dụ quá trình vận chuyển hàng từ khi có đơn bao gồm: KH đặt hàng -&gt; CS nhận đơn và thông báo -&gt; WH nhận thông tin đơn hàng và chuẩn bị hàng -&gt; WH giao hàng cho Shipper -&gt; Shipper vận chuyển đến tận nhà hoặc tới DC -&gt; KH nhận hàng từ shipper hoặc ra DC lấy.\n\nVậy dựa vào các đặc tính đó, DES có thể giúp bạn trả lời các câu hỏi như: Khi nào xe chở hàng? ETA và ETD cụ thể bao nhiêu ?, …\n\n  \n  \n  \n  \n    Hình 4:  Mô hình DES trong dự báo nhu cầu cho Volvo\n  \n  \n  \n  \n    Source: Link to Image\n  \n\nNhư hình trên này là 1 ứng dụng DES vào việc dự báo nhu cầu khách hàng của Volvo trong nghiên cứu của (JAGATHISHVAR JAYAKUMAR and LAURA ALBORS MARQUÉS 2020).\n\nABM: là mô hình dựa vào behaviors - hành vi của từng object và đưa chúng vào enviroment để tự tương tác và thu lại dữ liệu. Về lí thuyết,ABM sẽ chi tiết và đánh giá kĩ hơn DES nên đó cũng là lý do ABM được ưu tiên sử dụng trong thời gian gần đây nhưng điều này cũng đòi hỏi độ chính xác cao về dữ liệu đầu vào để tránh sự sai lệch do độ nhạy cảm cao của mô hình này. Còn trên thực tế, mô hình nào tốt hơn còn tùy vào trường hợp mà bạn đối mặt.\n\nMột ví dụ thực tế của mô hình ABM là trong nghiên cứu (Hiroyasu Inoue et al. 2023) về giả lập sự tác động của trận động đất GEJE nổi tiếng từng cản quết Nhật Bản đến hoạt động sản xuất của công ty.\n\n  \n  \n  \n  \n    Hình 5: Mô hình ABM dự báo sự mất mát kinh tế do ảnh hưởng bởi GEJE\n  \n  \n  \n  \n    Source: Link to Image\n  \n\nMô hình trên đã giả lập sự mất mát về kinh tế (economic loss) gây bởi supply chain disruption theo thời gian tính từ lúc cơn động đất xảy ra. Đồng thời kết quả cũng cho thấy sự khác biệt so với nghiên cứu trước đây và lý do của sự chênh lệch này là việc mất điện kéo dài ảnh hưởng nặng đến hoạt động sản xuất và gây tổn thất cho ngành sản xuất Nhật Bản.\nNhư vậy, các bạn có thể thấy tính ứng dụng cao của simulation trong đời thực. Đối với các bài toán thực tế, tùy vào mức độ phức tạp, người dùng có thể ưu tiên ABM hay DES hoặc có thể phối hợp cả hai thuật toán này.\nVậy để việc simulation diễn ra tốt, mình sẽ cập nhập thêm các kiến thức sau đây.\n\n2.1 Lý thuyết hàng chờ:\nĐầu tiên là Queueing hay còn gọi là hàng chờ là một chuỗi các đối tượng đang chờ đợi được phục vụ và hoàn thành yêu cầu của mình từ các server trong hệ thống. Nói một cách đơn giản là giống như bạn đi mua trà sữa và đang đứng chờ tới lượt mình để order, sau đó đợi trà sữa được làm xong và lấy trà sữa và trở về nhà. Với góc nhìn của khách hàng thì không ai muốn chờ đợi, còn góc nhìn của chủ cửa hàng thì không muốn hàng chờ phải dài (mặc dù như vậy đồng nghĩa với cửa hàng đang đông khách nhưng hàng chờ dài sẽ làm khó chịu khách hàng và dẫn đến mất khách).\n\n  \n  \n  \n  \n    Hình 6: Ví dụ về queueing trong quản lí nhà kho\n  \n  \n  \n  \n    Source: Link to Image\n  \n\nNhư vậy, mục tiêu là: đảm bảo hàng chờ ở mức tối ưu nhất để cân bằng giữa cấp độ phục vụ (Vd: đảm bảo khách hàng hài lòng) và chi phí. Lý do vì sao mình nói rằng là tối ưu nhất chứ không phải là giảm tới mức hàng chờ = 0 là vì hàng chờ luôn luôn tồn tại cho dù bạn có tốn bao nhiêu tài nguyên vào server. Nó giống như nghịch lý quy hoạch đô thị rằng: “Xây thêm đường sẽ không giảm kẹt xe” và nghịch lý vận tải: “Đường càng rộng thì càng kẹt xe” của Matthew A. Turner và Gilles Duranton, nghĩa là bạn chỉ giảm khoảng cách của hàng kẹt xe chứ không hoàn toàn xóa bỏ tình trạng kẹt xe. Vì vậy, ví dụ nếu cửa hàng của bạn luôn tồn tại hàng chờ cỡ 5-6 người/hàng thì bạn chỉ cần thuê thêm 1 nhân viên đứng trực là hàng chờ giảm còn 2-3 người thay vì 5 nhân viên để hàng chờ giảm còn 0 bởi như vậy là tốn chi phí và không hiệu quả.\nVậy làm sao để xây dựng mô hình hàng chờ cho cửa hàng của bạn ? Đầu tiên ta cần xác định được lượng khách hàng trong một khoảng thời gian cụ thể (Vd: ngày, tuần, tháng,…) tuân theo phân bố gì, trong đó các phân bố như phân phối hàm mũ, phân phối Poisson được sử dụng phổ biến.\n\n\nCode\n# Load necessary library\nset.seed(123)  \n\n# Define customer flow pattern for different times of the day\n# Morning rush: 8:30 AM - 10:30 AM\n# Midday: 10:30 AM - 2:00 PM\n# Afternoon: 2:00 PM - 4:30 PM\n# Evening rush: 4:30 PM - 7:00 PM\n# Late evening: 7:00 PM - 10:00 PM\n\n# Function to generate number of customers based on time of day\ngenerate_customers &lt;- function(time) {\n  hour &lt;- as.numeric(format(time, \"%H\"))\n  \n  if (hour &gt;= 8 && hour &lt; 10) {\n    # Morning rush (8:30 AM - 10:30 AM)\n    return(sample(20:35, 1))  # 20 to 35 customers\n  } else if (hour &gt;= 10 && hour &lt; 14) {\n    # Midday (10:30 AM - 2:00 PM)\n    return(sample(20:32, 1))  # 20 to 32 customers\n  } else if (hour &gt;= 14 && hour &lt; 16) {\n    # Afternoon slump (2:00 PM - 4:30 PM)\n    return(sample(10:18, 1))  # 10 to 18 customers\n  } else if (hour &gt;= 16 && hour &lt; 19) {\n    # Evening rush (4:30 PM - 7:00 PM)\n    return(sample(30:50, 1))  # 30 to 50 customers\n  } else if (hour &gt;= 19 && hour &lt;= 22) {\n    # Late evening (7:00 PM - 10:00 PM)\n    return(sample(12:18, 1))  # 12 to 18 customers\n  }\n}\n\ntime_intervals&lt;-seq(from = as.POSIXct(\"2024-11-11 08:30:00\",tz = \"UTC\"),\n\n                    to = as.POSIXct(\"2024-11-11 22:00:00\",tz = \"UTC\"),\n\n                    by = \"30 min\")\n\n# Apply the function to generate customer data for each time interval\ncustomer_data &lt;- sapply(time_intervals, generate_customers)\n\n# Create a data frame with time and customer count\ncoffee_data &lt;- data.frame(\n  Time = as.numeric(time_intervals)*1000,\n  Customers = customer_data\n)\n\nlibrary(highcharter)\nhchart(\n  coffee_data,\n  'line', \n  hcaes(y = Customers,\n        x = Time)\n  ) |&gt; \n  hc_xAxis(title = FALSE,type = \"datetime\") |&gt; \n  hc_yAxis(\n    title = list(text = \"Number of Customers\")\n  ) |&gt; \n  hc_title(text = \"No.Customer through a normal day in Coffee Shop\")\n\n\n\n\n\n\nCách xác định là chia lượng người vào cửa hàng theo từng khoảng thời gian bằng nhau, như trên ví dụ đây là 30 phút trong khoảng thời gian hoạt động từ 8h00 AM đến 22h00 PM. Kết quả kiểm định được trình bày bên dưới với giá trị p &lt; 0.05 cho thấy số lượng khách hàng tuân theo phân bố poisson (Mặc dù dữ liệu này được mình tạo ngẫu nhiên bởi chatGPT 😮😮😮).\n\nCount table:Chi-squared test:\n\n\n\n\nCode\nlibrary(gt)\n# Print Observed vs. Expected Counts Table\ngt(counts_df) %&gt;%\n  tab_header(\n    title = \"Observed Counts vs P-value\"\n  ) %&gt;%\n  tab_spanner(\n    label = \"Counts\",\n    columns = c(\"Observed\", \"P.value\")\n  ) %&gt;%\n  tab_style(\n    style = list(\n      cell_text(weight = \"bold\")\n    ),\n    locations = cells_column_labels(columns = everything())\n  )\n\n\n\n\n\n\n\n\nObserved Counts vs P-value\n\n\nCategory\nCounts\n\n\nObserved\nP.value\n\n\n\n\n12\n2\n0.0026\n\n\n14\n3\n0.0083\n\n\n15\n1\n0.0134\n\n\n17\n2\n0.0290\n\n\n18\n3\n0.0390\n\n\n21\n1\n0.0693\n\n\n22\n2\n0.0763\n\n\n23\n1\n0.0804\n\n\n24\n1\n0.0811\n\n\n25\n2\n0.0785\n\n\n29\n1\n0.0474\n\n\n30\n1\n0.0382\n\n\n32\n1\n0.0226\n\n\n34\n2\n0.0118\n\n\n36\n1\n0.0055\n\n\n37\n1\n0.0036\n\n\n38\n2\n0.0023\n\n\n39\n1\n0.0014\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Print Chi-squared Test Results Table\ngt(result_df) %&gt;%\n  tab_header(\n    title = \"Chi-squared Test Results\"\n  ) %&gt;%\n  tab_spanner(\n    label = \"Test Statistics\",\n    columns = c(\"Value\")\n  ) %&gt;%\n  tab_style(\n    style = list(\n      cell_text(weight = \"bold\")\n    ),\n    locations = cells_column_labels(columns = everything())\n  )\n\n\n\n\n\n\n\n\nChi-squared Test Results\n\n\nMetric\nTest Statistics\n\n\nValue\n\n\n\n\nChi-squared Statistic\n114.9442\n\n\nDegrees of Freedom\n17\n\n\np-value\n1.4e-16\n\n\n\n\n\n\n\n\n\n\nTiếp theo là xác định năng suất của server trong 1 đơn vị thời gian. Giả sử nhân viên của bạn có năng suất là như nhau và phục vụ trung bình được 1 đơn hàng/10 phút hay 6 đơn hàng/giờ thì ta có \\(\\mu\\) = 6\nSau đó chúng ta sẽ bắt đầu quá trình giả lập và bạn có thể sử dụng 2 cách: (i) Phương pháp giải tích (giải phương trình toán học bằng tay) hoặc (ii) Phương pháp máy tính (giả lập bằng máy). Với R thì bạn hoàn toàn làm điều này dễ hơn.\nNhư dưới đây là ví dụ về việc giả lập thời gian phục vụ của quán cà phê với 2 hoặc 3 hoặc 4 nhân viên trực quán.\n\n2 employee:3 employee:4 employee:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKết quả cho thấy cửa hàng nên thuê 4 người để đảm bảo server level ở dạng cao. Nếu cửa hàng chỉ thuê 2 người thì thời gian đợi phục vụ trung bình của khách hàng là khoảng 7.5 tiếng (Một con số hơi khủng, tưởng đang sử dụng dịch vụ của Vietjet cơ! 😄😄😄) trong khi nếu thuê thêm 2 người thì giảm xuống còn 41.5 phút ~ giảm thời gian chờ đợi xuống 11 lần.\n\n\n2.2 Lý thuyết thống kê:\nTiếp theo, bạn cần lý thuyết thống kê về chuyên ngành của vấn đề mà bạn đang mong muốn mô hình hóa. Việc xác định các đối tượng trong server và đối tượng mục tiêu cần giả lập cũng như các đặc tính cần có trong mô hình là quan trọng bởi chúng là sườn sống của mô hình giả lập. Ví dụ như quy trình hoạt động của quán cafe là như thế nào, sẽ hoạt động ra sao trong nhiều trường hợp,… càng rõ thì việc giả lập càng sát với thực tế.\nĐặc biệt với các ngành về y sinh học, giả lập quần thể là công việc hằng ngày của các nghiên cứu sinh nên việc hiểu rõ bản chất của quần thể đó quan trọng hơn cách thức hay phương pháp giả lập.\nVề code, bạn cần lưu ý rằng sample size - số lượng mẫu ảnh hưởng lớn đến độ chính xác (precision) của đo lường ảnh hưởng của biến đó. Điều này cũng tương tự với độ lặp lại (replication) nghĩa là bạn lặp lại nhiều lần việc tính toán thì kết quả sẽ tốt hoặc chính xác hơn.\nTiếp theo, ta sẽ thực hành trong R.\n\n\n\n    \n    \n    Go to Next Page\n    \n\n\n    \n        \n            Go to Next Page\n            ➔"
  }
]